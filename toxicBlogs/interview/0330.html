<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端各类知识点 | toxicDocs</title>
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/toxicDocs/awa.jpg">
    <meta name="description" content="  ">
    <meta name="referrer" content="no-referrer">
    
    <link rel="preload" href="/toxicDocs/assets/css/0.styles.aeb0f387.css" as="style"><link rel="preload" href="/toxicDocs/assets/js/app.57a67b61.js" as="script"><link rel="preload" href="/toxicDocs/assets/js/3.38eb45c0.js" as="script"><link rel="preload" href="/toxicDocs/assets/js/1.eb5625cb.js" as="script"><link rel="preload" href="/toxicDocs/assets/js/40.23bfa2cb.js" as="script"><link rel="prefetch" href="/toxicDocs/assets/js/10.2f38544c.js"><link rel="prefetch" href="/toxicDocs/assets/js/11.d980741a.js"><link rel="prefetch" href="/toxicDocs/assets/js/12.8d120472.js"><link rel="prefetch" href="/toxicDocs/assets/js/13.99a15f62.js"><link rel="prefetch" href="/toxicDocs/assets/js/14.012526be.js"><link rel="prefetch" href="/toxicDocs/assets/js/15.93c9f0b0.js"><link rel="prefetch" href="/toxicDocs/assets/js/16.fdf462c3.js"><link rel="prefetch" href="/toxicDocs/assets/js/17.6b897f4a.js"><link rel="prefetch" href="/toxicDocs/assets/js/18.e6bb1412.js"><link rel="prefetch" href="/toxicDocs/assets/js/19.28e235f5.js"><link rel="prefetch" href="/toxicDocs/assets/js/20.a6d64190.js"><link rel="prefetch" href="/toxicDocs/assets/js/21.cd460109.js"><link rel="prefetch" href="/toxicDocs/assets/js/22.e2928974.js"><link rel="prefetch" href="/toxicDocs/assets/js/23.d7217fb6.js"><link rel="prefetch" href="/toxicDocs/assets/js/24.e6f9072e.js"><link rel="prefetch" href="/toxicDocs/assets/js/25.0dd4caed.js"><link rel="prefetch" href="/toxicDocs/assets/js/26.10d4eabe.js"><link rel="prefetch" href="/toxicDocs/assets/js/27.e55db4be.js"><link rel="prefetch" href="/toxicDocs/assets/js/28.e62830f4.js"><link rel="prefetch" href="/toxicDocs/assets/js/29.04cc29ea.js"><link rel="prefetch" href="/toxicDocs/assets/js/30.a041c9eb.js"><link rel="prefetch" href="/toxicDocs/assets/js/31.896142db.js"><link rel="prefetch" href="/toxicDocs/assets/js/32.9506dd06.js"><link rel="prefetch" href="/toxicDocs/assets/js/33.c7a1c1ce.js"><link rel="prefetch" href="/toxicDocs/assets/js/34.94330620.js"><link rel="prefetch" href="/toxicDocs/assets/js/35.7a14c7b2.js"><link rel="prefetch" href="/toxicDocs/assets/js/36.ec763fd2.js"><link rel="prefetch" href="/toxicDocs/assets/js/37.14c00b36.js"><link rel="prefetch" href="/toxicDocs/assets/js/38.988ef3eb.js"><link rel="prefetch" href="/toxicDocs/assets/js/39.faae47c5.js"><link rel="prefetch" href="/toxicDocs/assets/js/4.7bb9ec6b.js"><link rel="prefetch" href="/toxicDocs/assets/js/41.683fdc39.js"><link rel="prefetch" href="/toxicDocs/assets/js/42.d908406e.js"><link rel="prefetch" href="/toxicDocs/assets/js/43.00b23b2c.js"><link rel="prefetch" href="/toxicDocs/assets/js/44.8e7e035e.js"><link rel="prefetch" href="/toxicDocs/assets/js/45.6c60b62b.js"><link rel="prefetch" href="/toxicDocs/assets/js/46.43a17a5b.js"><link rel="prefetch" href="/toxicDocs/assets/js/47.b1f87e3d.js"><link rel="prefetch" href="/toxicDocs/assets/js/48.27e9d521.js"><link rel="prefetch" href="/toxicDocs/assets/js/49.a87e6049.js"><link rel="prefetch" href="/toxicDocs/assets/js/5.42cea8f5.js"><link rel="prefetch" href="/toxicDocs/assets/js/50.3f845486.js"><link rel="prefetch" href="/toxicDocs/assets/js/51.aad4770d.js"><link rel="prefetch" href="/toxicDocs/assets/js/52.b5aee4d6.js"><link rel="prefetch" href="/toxicDocs/assets/js/53.7d1b20b5.js"><link rel="prefetch" href="/toxicDocs/assets/js/54.36c7ffbb.js"><link rel="prefetch" href="/toxicDocs/assets/js/55.aa1925a2.js"><link rel="prefetch" href="/toxicDocs/assets/js/56.5b73f487.js"><link rel="prefetch" href="/toxicDocs/assets/js/57.8aaf393f.js"><link rel="prefetch" href="/toxicDocs/assets/js/58.7206a865.js"><link rel="prefetch" href="/toxicDocs/assets/js/59.995c60aa.js"><link rel="prefetch" href="/toxicDocs/assets/js/6.44f91839.js"><link rel="prefetch" href="/toxicDocs/assets/js/60.9d75e7d3.js"><link rel="prefetch" href="/toxicDocs/assets/js/61.0437caac.js"><link rel="prefetch" href="/toxicDocs/assets/js/62.d5e379f6.js"><link rel="prefetch" href="/toxicDocs/assets/js/63.df830a4e.js"><link rel="prefetch" href="/toxicDocs/assets/js/64.c0347713.js"><link rel="prefetch" href="/toxicDocs/assets/js/65.f739dbae.js"><link rel="prefetch" href="/toxicDocs/assets/js/66.4e4ee166.js"><link rel="prefetch" href="/toxicDocs/assets/js/67.2354d32b.js"><link rel="prefetch" href="/toxicDocs/assets/js/68.6592aae5.js"><link rel="prefetch" href="/toxicDocs/assets/js/69.20cb4424.js"><link rel="prefetch" href="/toxicDocs/assets/js/7.50e8f11a.js"><link rel="prefetch" href="/toxicDocs/assets/js/70.25741af2.js"><link rel="prefetch" href="/toxicDocs/assets/js/71.966e9723.js"><link rel="prefetch" href="/toxicDocs/assets/js/72.6b0b893a.js"><link rel="prefetch" href="/toxicDocs/assets/js/73.26549001.js"><link rel="prefetch" href="/toxicDocs/assets/js/74.f0c3f927.js"><link rel="prefetch" href="/toxicDocs/assets/js/75.95abd215.js"><link rel="prefetch" href="/toxicDocs/assets/js/76.40ab8ae7.js"><link rel="prefetch" href="/toxicDocs/assets/js/77.eb5ad441.js"><link rel="prefetch" href="/toxicDocs/assets/js/78.136d9557.js"><link rel="prefetch" href="/toxicDocs/assets/js/79.22c9557f.js"><link rel="prefetch" href="/toxicDocs/assets/js/8.fe737a6b.js"><link rel="prefetch" href="/toxicDocs/assets/js/80.3e28bff5.js"><link rel="prefetch" href="/toxicDocs/assets/js/81.9c7636a5.js"><link rel="prefetch" href="/toxicDocs/assets/js/82.762018d5.js"><link rel="prefetch" href="/toxicDocs/assets/js/83.dc334460.js"><link rel="prefetch" href="/toxicDocs/assets/js/84.662cd3b9.js"><link rel="prefetch" href="/toxicDocs/assets/js/9.6597a9e8.js">
    <link rel="stylesheet" href="/toxicDocs/assets/css/0.styles.aeb0f387.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-6f8f7dda><div data-v-6f8f7dda><div class="password-shadow password-wrapper-out" style="display:none;" data-v-f68096de data-v-6f8f7dda data-v-6f8f7dda><h3 class="title" data-v-f68096de>toxicDocs</h3> <p class="description" data-v-f68096de>  </p> <label id="box" class="inputBox" data-v-f68096de><input type="password" value="" data-v-f68096de> <span data-v-f68096de>Konck! Knock!</span> <button data-v-f68096de>OK</button></label> <div class="footer" data-v-f68096de><span data-v-f68096de><i class="iconfont reco-theme" data-v-f68096de></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-f68096de>vuePress-theme-reco</a></span> <span data-v-f68096de><i class="iconfont reco-copyright" data-v-f68096de></i> <a data-v-f68096de><span data-v-f68096de>toxic</span>
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-6f8f7dda><header class="navbar" data-v-6f8f7dda><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/toxicDocs/" class="home-link router-link-active"><img src="/toxicDocs/7.jpg" alt="toxicDocs" class="logo"> <span class="site-name">toxicDocs</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/toxicDocs/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      目录索引
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/算法/" class="nav-link"><i class="undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/项目/" class="nav-link"><i class="undefined"></i>
  项目
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/面试/" class="nav-link"><i class="undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/小程序/" class="nav-link"><i class="undefined"></i>
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/源码/" class="nav-link"><i class="undefined"></i>
  源码
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/Graduation/" class="nav-link"><i class="undefined"></i>
  Graduation
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/教程/" class="nav-link"><i class="undefined"></i>
  教程
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/other/" class="nav-link"><i class="undefined"></i>
  other
</a></li></ul></div></div><div class="nav-item"><a href="/toxicDocs/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签索引
</a></div><div class="nav-item"><a href="/toxicDocs/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-6f8f7dda></div> <aside class="sidebar" data-v-6f8f7dda><div class="personal-info-wrapper" data-v-cc06b9e8 data-v-6f8f7dda><img src="/toxicDocs/awa.jpg" alt="author-avatar" class="personal-img" data-v-cc06b9e8> <h3 class="name" data-v-cc06b9e8>
    toxic
  </h3> <div class="num" data-v-cc06b9e8><div data-v-cc06b9e8><h3 data-v-cc06b9e8>63</h3> <h6 data-v-cc06b9e8>Articles</h6></div> <div data-v-cc06b9e8><h3 data-v-cc06b9e8>17</h3> <h6 data-v-cc06b9e8>Tags</h6></div></div> <ul class="social-links" data-v-cc06b9e8></ul> <hr data-v-cc06b9e8></div> <nav class="nav-links"><div class="nav-item"><a href="/toxicDocs/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      目录索引
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/算法/" class="nav-link"><i class="undefined"></i>
  算法
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/项目/" class="nav-link"><i class="undefined"></i>
  项目
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/前端/" class="nav-link"><i class="undefined"></i>
  前端
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/面试/" class="nav-link"><i class="undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/小程序/" class="nav-link"><i class="undefined"></i>
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/源码/" class="nav-link"><i class="undefined"></i>
  源码
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/Graduation/" class="nav-link"><i class="undefined"></i>
  Graduation
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/教程/" class="nav-link"><i class="undefined"></i>
  教程
</a></li><li class="dropdown-item"><!----> <a href="/toxicDocs/categories/other/" class="nav-link"><i class="undefined"></i>
  other
</a></li></ul></div></div><div class="nav-item"><a href="/toxicDocs/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签索引
</a></div><div class="nav-item"><a href="/toxicDocs/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Interview</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/toxicDocs/toxicBlogs/interview/0330.html" aria-current="page" class="active sidebar-link">前端各类知识点</a></li><li><a href="/toxicDocs/toxicBlogs/interview/html5.html" class="sidebar-link">html5</a></li><li><a href="/toxicDocs/toxicBlogs/interview/js.html" class="sidebar-link">事件代理 ×</a></li><li><a href="/toxicDocs/toxicBlogs/interview/js1.html" class="sidebar-link">原型和继承</a></li><li><a href="/toxicDocs/toxicBlogs/interview/leetcode.html" class="sidebar-link">1. 数组扁平化</a></li><li><a href="/toxicDocs/toxicBlogs/interview/被挂之路.html" class="sidebar-link">/toxicBlogs/interview/被挂之路.html</a></li><li><a href="/toxicDocs/toxicBlogs/interview/面经.html" class="sidebar-link">JavaScript易错点</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-f68096de data-v-6f8f7dda><h3 class="title" data-v-f68096de>前端各类知识点</h3> <!----> <label id="box" class="inputBox" data-v-f68096de><input type="password" value="" data-v-f68096de> <span data-v-f68096de>Konck! Knock!</span> <button data-v-f68096de>OK</button></label> <div class="footer" data-v-f68096de><span data-v-f68096de><i class="iconfont reco-theme" data-v-f68096de></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-f68096de>vuePress-theme-reco</a></span> <span data-v-f68096de><i class="iconfont reco-copyright" data-v-f68096de></i> <a data-v-f68096de><span data-v-f68096de>toxic</span>
          
        <!---->
        2024
      </a></span></div></div> <div data-v-6f8f7dda><div data-v-6f8f7dda><main class="page" style="padding-right:0;"><section style="display:;"><div class="page-title"><h1 class="title">前端各类知识点</h1> <div data-v-1e62957f><i class="iconfont reco-account" data-v-1e62957f><span data-v-1e62957f>toxic</span></i> <i class="iconfont reco-date" data-v-1e62957f><span data-v-1e62957f>3/30/2023</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="_2023年3月30日-星期四"><a href="#_2023年3月30日-星期四" class="header-anchor">#</a> 2023年3月30日 星期四</h1> <h2 id="_1-src和href的区别"><a href="#_1-src和href的区别" class="header-anchor">#</a> 1. <code>src</code>和<code>href</code>的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>src: <span class="token builtin class-name">source</span>

<span class="token number">1</span>. 指向外部资源，指向的内容会被嵌入到当前标签所在的位置。
<span class="token number">2</span>. 一般是js脚本，图片资源或者 iframe 框架元素。
<span class="token number">3</span>. 当请求到src内容时，浏览器会暂停其他资源的下载和处理，直到该资源加载编译与执行完毕。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>href: 超文本引用 HypeText Reference

<span class="token number">1</span>. 其实也是指向网络资源，它是建立起当前文档与其的链接。
<span class="token number">2</span>. 请求过程中是并行请求网络资源，不会暂停对其他资源的处理。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_2-对-html-语义化的理解"><a href="#_2-对-html-语义化的理解" class="header-anchor">#</a> 2. 对 <code>HTML</code> 语义化的理解</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 语义化的意思就是 根据html页面内容的结构化使用合适的标签 —— 用正确的标签做正确的事情
<span class="token number">2</span>. 优点：
有利于SEO，对机器友好，语义化标签下有更丰富的表现力，更适合搜索引擎的爬虫爬取有效信息。
对开发者友好，增强了页面内容的可读性，结构更加清晰，有利于开发与维护。
<span class="token number">3</span>. H5的语义化标签有
Header Footer Aside Nav Article Section Main
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_3-script下defer和async的区别"><a href="#_3-script下defer和async的区别" class="header-anchor">#</a> 3. script下defer和async的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>相同点：
<span class="token number">1</span>. 首先这个script下的src在嵌入到当前标签页处的时候，本身是暂停其他资源，直到它加载编译执行结束
<span class="token number">2</span>. defer和async都能使script中的js脚本进行异步加载，不阻塞到页面其他资源的加载以及页面的解析
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>不同点：
<span class="token number">1</span>. 执行顺序：多个script标签内容的执行
   多个defer：加载顺序是不确定的；多个async：按照加载顺序执行
<span class="token number">2</span>. 脚本是否并行执行
   是分为加载+执行的嘛
   defer: js脚本的加载与页面解析是并行的。但是js脚本的执行是在所有元素解析完成之后才执行的。
   async: js脚本的加载与执行都是与页面一致并行的。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230330185841443.png" alt="image-20230330185841443"></p> <h2 id="_4-html5新特性"><a href="#_4-html5新特性" class="header-anchor">#</a> 4. <code>HTML5</code>新特性</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 语义化标签
   Header
   Footer
   Aside
   Nav
   Section
   Main
   Article

<span class="token number">2</span>. input属性     表单类型 <span class="token builtin class-name">type</span>      表单事件

<span class="token number">3</span>. API
   拖拽API       媒体标签  audio video
   画布API       SVG: 可伸缩矢量图形      地理API

<span class="token number">4</span>. localStorage
   sessionStorage
   
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="_5-行内元素-块级元素和空元素"><a href="#_5-行内元素-块级元素和空元素" class="header-anchor">#</a> 5. 行内元素，块级元素和空元素</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 行内元素：span input strong img
<span class="token number">2</span>. 块级元素：div p  ol ul li  h1 ~ h6 
<span class="token number">3</span>. 空元素：br meta <span class="token function">link</span>  hr img input
没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_6-doctype的作用"><a href="#_6-doctype的作用" class="header-anchor">#</a> 6. <code>DocType</code>的作用</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>DocType是HTML5一种标准通用标记语言的文档声明类型，它规定浏览器以何种（html/xhtml<span class="token punctuation">)</span>文档类型来解析文档。
不同的渲染模式会影响文档的css和js脚本的解析。
有两种不同的模式:
<span class="token number">1</span>. CSS1Compat: 标准模式
<span class="token number">2</span>. BackCompat: 怪异模式
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_7-meta标签"><a href="#_7-meta标签" class="header-anchor">#</a> 7. <code>meta</code>标签</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>meta 标签中由name和content属性定义；用来描述网页文档的属性

<span class="token number">1</span>. charset 编码类型；描述html文档的编码类型

<span class="token number">2</span>. name:<span class="token string">&quot;keywords&quot;</span>  <span class="token string">&quot;descriptiom&quot;</span> <span class="token string">&quot;viewport&quot;</span> <span class="token string">&quot;robots&quot;</span>
有相对应的content属性。 robots <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token string">&quot;all&quot;</span> <span class="token string">&quot;none&quot;</span> <span class="token string">&quot;index&quot;</span> <span class="token string">&quot;follow&quot;</span> <span class="token string">&quot;noindex&quot;</span> <span class="token string">&quot;nofollow&quot;</span>
index:文件可以被检索到    follow:页面上的链接可以被查询

<span class="token number">3</span>. http-equiv:<span class="token string">&quot;refresh&quot;</span> 页面重定向和刷新 搭配content 是 <span class="token string">&quot;0;url=&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_8-web-worker的理解"><a href="#_8-web-worker的理解" class="header-anchor">#</a> 8. <code>web worker</code>的理解</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>前提: 因为JavaScript是单线程的，意味着所有任务都只能在一个线程中完成。

所以: webWorker就是为JavaScript创建多线程环境，允许JavaScript主线程创建了一个worker线程，分配一些任务在worker线程上运行。
主线程与webworker线程同时运行互不干扰，等到worker线程完成任务后，通过postMessage将结果返回给主线程。

好处: 一些计算密集型或高延迟的任务就被webWorker线程负担了，这样主线程主要负责UI交互就会更加流畅，不会被阻塞或拖慢
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>注意点：
<span class="token number">1</span>. 同源  worker线程运行的脚本与主线程运行的脚本必须同源
<span class="token number">2</span>. Dom操作  worker线程不能使用document,window等对象，但可以使用location和navigator
<span class="token number">3</span>. 只能运行网络资源 worker线程不能打开本地资源 file:// 
<span class="token number">4</span>. 通信联系 worker线程与主线程不在同一个上下文，通信只能通过消息传递
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_9-title-h1-b-strong-i-em"><a href="#_9-title-h1-b-strong-i-em" class="header-anchor">#</a> 9. <code>title</code>/<code>h1</code> <code>b</code>/<code>strong</code> <code>i</code>/<code>em</code></h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. title是网站标题：可以直接告诉搜索引擎和用户网站的信息，显示在标题tab栏中
<span class="token number">2</span>. h1是文档中层次分明的标题，面向用户，更突出其视觉效果
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. b与i一致，都是样式但是没有实际含义；strong与em都可以通过css添加样式
<span class="token number">2</span>. b<span class="token punctuation">(</span>bold<span class="token punctuation">)</span>实体标签，用来给文字加粗            strong逻辑标签用来加强字符语气，表示内容重要
<span class="token number">3</span>. i<span class="token punctuation">(</span>italic<span class="token punctuation">)</span>实体标签，用来给文字倾斜——术语等  em<span class="token punctuation">(</span>emphasis<span class="token punctuation">)</span>是逻辑标签，强调文本内容
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_10-svg和canvas比较"><a href="#_10-svg和canvas比较" class="header-anchor">#</a> 10 <code>SVG</code>和<code>Canvas</code>比较</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>基本内容
<span class="token number">1</span>. svg使用xml描述2d图像 canvas通过js绘制2d图形
<span class="token number">2</span>. svg是矢量图  canvas是位图，即放大后可以看到该图的像素点会出现锯齿状<span class="token punctuation">(</span>依靠分辨率会失真<span class="token punctuation">)</span>
<span class="token number">3</span>. svg支持事件绑定，但canvas只能给整个画布添加事件

<span class="token number">1</span>. svg绘制的图像是一个对象，如果对象属性发生改变，浏览器将重新绘制
   canvas绘制完毕，浏览器不再关注 直到位置发生改变才重新绘制
<span class="token number">2</span>. svg不适用图形密集，频繁操作Dom会减慢渲染的速度 Canvas可以
<span class="token number">3</span>. svg适合做地图 canvas渲染性能高,用来开发游戏或统计图
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/8eef29b6d6ab496ea356153dc86c4379~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="01.jpg"></p> <p><img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230331105729029.png" alt="image-20230331105729029"></p> <h2 id="_11-head标签有什么用-其中什么标签必不可少"><a href="#_11-head标签有什么用-其中什么标签必不可少" class="header-anchor">#</a> 11 <code>head</code>标签有什么用? 其中什么标签必不可少</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. <span class="token function">head</span> 标签用于定义文档的头部，是所有头部元素的容器。一般在其中定义脚本文件，直到浏览器在哪里找到样式表和文档的元信息。
<span class="token number">2</span>. 描述了各种各样的属性与信息 但都不会作为页面内容被用户看到
<span class="token number">3</span>. 一般在head中的标签： base meta title <span class="token function">link</span> script style
<span class="token number">4</span>. title是定义文档标题，唯一必需
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h1 id="_2023年3月31日-星期五"><a href="#_2023年3月31日-星期五" class="header-anchor">#</a> 2023年3月31日 星期五</h1> <h2 id="_1-css选择器及优先级"><a href="#_1-css选择器及优先级" class="header-anchor">#</a> 1. <code>css</code>选择器及优先级</h2> <p><img src="https://pic3.zhimg.com/v2-b1a9fedf320754acb1d7766c6548d5f6_r.jpg" alt="img"></p> <blockquote><p><strong>权重记忆口诀</strong>：从0开始，一个内联样式+1000，一个<code>id</code>选择器+100，一个属性选择器、<code>class</code>类选择器或者伪类+10，一个标签选择器，或者伪元素+1，通配符+0。</p></blockquote> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>样式表来源不同：优先顺序为
内联 <span class="token assign-left variable">style</span><span class="token operator">=</span><span class="token string">&quot;&quot;</span> <span class="token operator">&gt;</span> 内部 style<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">&gt;</span> 外部 <span class="token function">link</span> <span class="token operator">&gt;</span> 浏览器用户自定义样式 <span class="token operator">&gt;</span> 浏览器默认样式
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_2-display的属性值及作用"><a href="#_2-display的属性值及作用" class="header-anchor">#</a> 2. <code>display</code>的属性值及作用</h2> <table><thead><tr><th style="text-align:center;">属性值</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td style="text-align:center;"><code>none</code></td> <td style="text-align:center;">元素不显示，从文档流中删除</td></tr> <tr><td style="text-align:center;"><code>block</code></td> <td style="text-align:center;">块元素类型，宽度为父元素宽度，可设置宽高。换行显示</td></tr> <tr><td style="text-align:center;"><code>inline</code></td> <td style="text-align:center;">行元素类型，宽度为自身内容宽度。不可设置宽高。不换行显示</td></tr> <tr><td style="text-align:center;"><code>inline-block</code></td> <td style="text-align:center;">行元素类型。宽度为自身内容宽度。可设置宽高。不换行显示</td></tr> <tr><td style="text-align:center;"><code>inherit</code></td> <td style="text-align:center;">继承父元素的<code>display</code>属性</td></tr> <tr><td style="text-align:center;"><code>list-item</code></td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;"><code>table</code></td> <td style="text-align:center;"></td></tr></tbody></table> <h2 id="_3-display的block、inline和inline-block的区别"><a href="#_3-display的block、inline和inline-block的区别" class="header-anchor">#</a> 3. <code>display</code>的<code>block</code>、<code>inline</code>和<code>inline-block</code>的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. block 会独占一行，多个元素会另起一行，可以设置width height padding margin
<span class="token number">2</span>. inline 不会独占一行，width就是元素本身内容宽度，设置width height无效。padding和margin只能是指水平方向，垂直方向不起效果
<span class="token number">3</span>. inline-block 不会独占一行 但可以设置width height padding margin
                将对象设置为行内元素，但对象的内容作为block呈现
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_4-隐藏元素的方法有哪些"><a href="#_4-隐藏元素的方法有哪些" class="header-anchor">#</a> 4. 隐藏元素的方法有哪些</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>前提：
<span class="token number">0</span>. 渲染 网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断的触发重排和重绘
<span class="token number">1</span>. 重排 重新生成布局 重新排列元素 但重排之后将重新绘制受到重排影响的部分
<span class="token number">2</span>. 重绘 某些元素的外观被改变 如填充颜色等 仅仅改变外观，是不会引起网页重新布局的
结论：
<span class="token number">1</span>. 重绘不一定导致重排 重排一定导致重绘
<span class="token number">2</span>. 都会影响性能，但是重排会付出高额的性能代价，应该尽量避免
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><a href="https://juejin.cn/post/6844904083212468238" target="_blank" rel="noopener noreferrer">重排(reflow)和重绘(repaint) - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/170af501e710ce67~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image"></p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>页面生成的过程：
<span class="token number">1</span>. HTML解析器将HTML解析为 DOM树
<span class="token number">2</span>. CSS解析器将CSS解析为 CSSOM树
<span class="token number">3</span>. 结合DOM和CSSOM 生成一颗渲染树
<span class="token number">4</span>. 渲染树生成布局（flow）浏览器在屏幕上画出节点
<span class="token number">5</span>. 将布局绘制（paint）在屏幕上 显示出整个页面
<span class="token number">4</span>+5. 就是通常所说的渲染
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>常规方法：
<span class="token number">1</span>. display:none<span class="token punctuation">;</span>   结构消失，会触发重排和重绘
   彻底的隐藏了元素，不占据空间，不影响布局，响应事件失效
<span class="token number">2</span>. opacity:0<span class="token punctuation">;</span>      不触发重排和重绘
   只是透明度设置为0，在页面上看不到，但仍占据空间也可响应事件
   会被读屏软件阅读，像其他元素一样
<span class="token number">3</span>. visibility:hidden<span class="token punctuation">;</span>       触发重绘
   类似opacity属性，在页面上看不到但仍占据空间。但不响应交互事件
   此外也不会被读屏软件读取内容
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>逃逸视窗
<span class="token number">1</span>. position+left+top  超大父边距将元素抛出视图 定位本身脱离文档流所以不占据空间
<span class="token number">2</span>. translate<span class="token punctuation">(</span>-9999px<span class="token punctuation">)</span> 会占据空间，不过元素不在视窗内无法交互 （对行内元素无效）
<span class="token number">3</span>. transform:scale<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>/skew<span class="token punctuation">(</span>90deg<span class="token punctuation">)</span><span class="token punctuation">;</span> 2d变换隐藏 占据空间不可交互   （对行内元素无效）
<span class="token number">4</span>. clip-path:circle<span class="token punctuation">(</span>0px<span class="token punctuation">)</span> 利用可裁剪创建元素的可显示区域，区域外会隐藏 不可交互
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. z-index  层叠上下文在合适的情况遮挡住元素
<span class="token number">2</span>. 压缩空间
   height:0<span class="token punctuation">;</span>width:0<span class="token punctuation">;</span>padding:0<span class="token punctuation">;</span>margin:0<span class="token punctuation">;</span>border:none<span class="token punctuation">;</span>overflow:hidden
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><a href="https://juejin.cn/post/7210412098810740795#heading-0" target="_blank" rel="noopener noreferrer">聊聊 CSS 隐藏元素的 10 种实用方法 - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844903456545701901#heading-5" target="_blank" rel="noopener noreferrer">CSS 隐藏元素的八种方法 - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_5-display-none-与-visibility-hidden的区别"><a href="#_5-display-none-与-visibility-hidden的区别" class="header-anchor">#</a> 5. <code>display:none</code> 与 <code>visibility:hidden</code>的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>共同点：都是让元素隐藏 不可见 都无法被读取
区别：
<span class="token number">1</span>. 在渲染树上
   display:none 直接在渲染树上消失，渲染时不占据任何空间
   visibility:hidden 不会消失，继续占据页面空间，只是内容被隐藏
<span class="token number">2</span>. 是否继承属性
   display:noen 子元素不会继承该属性，随着父元素一起消失在渲染树上
   visibility:hidden 是继承属性 子元素不可见是因为继承了，修改为visible就可见了
<span class="token number">3</span>. 是否造成重排重绘制
   display:none 不占据空间 导致重排有可能导致重绘
   visibility:hidden 占据空间 不可见 导致重绘
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_6-对盒模型的理解"><a href="#_6-对盒模型的理解" class="header-anchor">#</a> 6. 对盒模型的理解</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>盒模型：IE盒模型（怪异盒模型） 标准盒模型
属性:box-sizing:   content-box<span class="token punctuation">(</span>IE<span class="token punctuation">)</span>  border-box<span class="token punctuation">(</span>standard<span class="token punctuation">)</span>
组成: content<span class="token punctuation">(</span>width height<span class="token punctuation">)</span> padding margin border
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>区别:
<span class="token number">1</span>. 标准盒模型设置的width和height就是占据页面的宽高 包括了content padding border
<span class="token number">2</span>. IE盒模型设置的width和height就是单纯的content内容 实际上的宽高还要大于设置的，包括了content+padding+border

当然 外边距就不包括在里面啦
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_7-单行、多行文本溢出隐藏"><a href="#_7-单行、多行文本溢出隐藏" class="header-anchor">#</a> 7. 单行、多行文本溢出隐藏</h2> <ul><li>单行文本溢出</li></ul> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>              // 溢出隐藏
<span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span>       // 溢出用省略号显示
<span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span>           // 规定段落中的文本不进行换行
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>多行文本溢出</li></ul> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
<span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span>

<span class="token property">display</span><span class="token punctuation">:</span> box<span class="token punctuation">;</span>
<span class="token property">box-orient</span><span class="token punctuation">:</span> vertical<span class="token punctuation">;</span>
<span class="token property">line-clamp</span><span class="token punctuation">:</span> 3<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>考虑浏览器的兼容问题，要加前面加上<code>-webkit-</code>来兼容一部分浏览器。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token property">display</span><span class="token punctuation">:</span> -webkit-box<span class="token punctuation">;</span>
<span class="token property">-webkit-box-orient</span><span class="token punctuation">:</span> vertical<span class="token punctuation">;</span>
<span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span> 3<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_8-两栏布局实现"><a href="#_8-两栏布局实现" class="header-anchor">#</a> 8. 两栏布局实现</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>左边一栏宽度固定 右边一栏宽度自适应

<span class="token number">1</span>. 利用浮动 左侧设置固定宽度并向左浮动 右侧margin-left宽度为auto 占满整个父元素

.left<span class="token punctuation">{</span>
	float:left<span class="token punctuation">;</span>
	width:200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.right<span class="token punctuation">{</span>
	width:auto<span class="token punctuation">;</span>            // 不设置也可填充剩余部分
	margin-left:200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">2</span>. 利用浮动 左侧固定宽度且左浮动 右侧overflow:hidden<span class="token punctuation">(</span>触发BFC<span class="token punctuation">)</span>
.left<span class="token punctuation">{</span>
	width: 200px<span class="token punctuation">;</span>
	float: left<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.right<span class="token punctuation">{</span>
	overflow: hidden<span class="token punctuation">;</span>    // 触发块级格式化上下文BFC
	// 具有BFC的元素仍然保持流体特性也就是自动填充除浮动外的剩余空间
	// 不与浮动交集 自动退避浮动元素宽度的距离
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">3</span>. 利用flex布局 父级元素设置弹性布局 左侧固定宽度 右侧元素flex:1
.outer<span class="token punctuation">{</span>
	display: flex<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.left<span class="token punctuation">{</span>
	width: 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.right<span class="token punctuation">{</span>
	flex: <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">4</span>. 使用绝对定位 父级元素设置相对定位 右侧绝对 left right
.outer<span class="token punctuation">{</span>
	position: relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.left<span class="token punctuation">{</span>
	width: 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.right<span class="token punctuation">{</span>
	position: absolute<span class="token punctuation">;</span>
	top: <span class="token number">0</span><span class="token punctuation">;</span>
	right: <span class="token number">0</span><span class="token punctuation">;</span>
	left: 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_9-三栏布局实现"><a href="#_9-三栏布局实现" class="header-anchor">#</a> 9. 三栏布局实现</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>左右两栏宽度固定 中间一栏自适应的布局
<span class="token number">1</span>. 左右利用绝对定位 和 中间使用margin
.outer<span class="token punctuation">{</span>
	position: relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.left<span class="token punctuation">{</span>
	position: absolute<span class="token punctuation">;</span>
	width: 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.right<span class="token punctuation">{</span>
	positon: absolute<span class="token punctuation">;</span>
	right: <span class="token number">0</span><span class="token punctuation">;</span>   // 固定在右侧，此时在下一行
	top: <span class="token number">0</span><span class="token punctuation">;</span>     // 固定与center在同一行
	width: 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.center<span class="token punctuation">{</span>
	margin: <span class="token number">0</span> 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">2</span>. 父元素设置弹性盒子布局  中间一栏设置flex为1即可 其中两栏固定宽度
.outer<span class="token punctuation">{</span>
	display: flex<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.left<span class="token punctuation">{</span>
	width: 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.right<span class="token punctuation">{</span>
	width: 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.center<span class="token punctuation">{</span>
	flex: <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">3</span>. 左右两栏利用浮动，一个向左一个向右 中间使用margin隔开
.left<span class="token punctuation">{</span>
	float:left<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.right<span class="token punctuation">{</span>
	float:right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.center<span class="token punctuation">{</span>
	margin: <span class="token number">0</span> 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
注意：此处的html中center要放在最下面，而不是平时的中间
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="双飞翼布局"><a href="#双飞翼布局" class="header-anchor">#</a> 双飞翼布局</h3> <blockquote><p>中间<code>div</code>外层又包裹了一层<code>div</code>，在该子<code>div</code>里用<code>margin-left</code>和<code>margin-right</code>为左右两栏<code>div</code>留出位置</p></blockquote> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">.wraper</span><span class="token punctuation">{</span>
    <span class="token comment">/*包裹在中间一栏外的容器*/</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.center</span><span class="token punctuation">{</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> 0 200px<span class="token punctuation">;</span> <span class="token comment">/*空出两边的位置*/</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.left</span><span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>
    <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.right</span><span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
    <span class="token property">margin-left</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>outer<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>wraper<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>center<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
            center
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>left<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>right<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="圣杯布局"><a href="#圣杯布局" class="header-anchor">#</a> 圣杯布局</h3> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">body,html</span><span class="token punctuation">{</span>
    <span class="token property">padding</span><span class="token punctuation">:</span> 0 200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.center</span><span class="token punctuation">{</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.right</span><span class="token punctuation">{</span>
    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">margin-left</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
    <span class="token property">right</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.left</span><span class="token punctuation">{</span>
    <span class="token property">float</span><span class="token punctuation">:</span>left<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>
    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
    <span class="token property">left</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>center<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>center<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>left<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>left<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>right<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>right<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h1 id="_2023年4月1日-星期六"><a href="#_2023年4月1日-星期六" class="header-anchor">#</a> 2023年4月1日 星期六</h1> <h2 id="_1-水平垂直居中实现"><a href="#_1-水平垂直居中实现" class="header-anchor">#</a> 1. 水平垂直居中实现</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 利用绝对定位和translate （需要考虑浏览器兼容问题）
.parent<span class="token punctuation">{</span>
	position: relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.child<span class="token punctuation">{</span>
	position: absolute<span class="token punctuation">;</span>
	left: <span class="token number">50</span>%<span class="token punctuation">;</span>
	top: <span class="token number">50</span>%<span class="token punctuation">;</span>
	transform: translate<span class="token punctuation">(</span>-50%,-50%<span class="token punctuation">)</span><span class="token punctuation">;</span>
	// margin-top: -50px<span class="token punctuation">;</span>  height/2
	// margin-left: -50px<span class="token punctuation">;</span>  width/2
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">2</span>. 利用绝对定位 设置四个方向都为0 margin为auto （需要盒子有宽高）
.parent<span class="token punctuation">{</span>
	position: relative<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
.child<span class="token punctuation">{</span>
	position: absolute<span class="token punctuation">;</span>
	top: <span class="token number">0</span><span class="token punctuation">;</span>
	left: <span class="token number">0</span><span class="token punctuation">;</span>
	bottom: <span class="token number">0</span><span class="token punctuation">;</span>
	right: <span class="token number">0</span><span class="token punctuation">;</span>     // 对应方向实现平分
	margin: auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">3</span>. 弹性布局
.parent<span class="token punctuation">{</span>
	display: flex<span class="token punctuation">;</span>
	justify-content: center<span class="token punctuation">;</span>
	align-items: center<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_2-对flex布局的理解及其使用场景"><a href="#_2-对flex布局的理解及其使用场景" class="header-anchor">#</a> 2. 对Flex布局的理解及其使用场景</h2> <p><a href="https://zhuanlan.zhihu.com/p/393849980" target="_blank" rel="noopener noreferrer">彻底理解flex弹性布局，看这一篇就够了！ - 知乎 (zhihu.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://vue3js.cn/interview/css/flexbox.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noopener noreferrer">面试官：说说flexbox（弹性盒布局模型）,以及适用场景？ | web前端面试 - 面试官系列 (vue3js.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 概念
   Flex布局是Flexible box的缩写，意思为弹性布局，用来给盒模型提供最大的灵活性。行内元素也可以使用弹性布局。采用Flex布局的元素，被称为Flex容器，简称容器。所有的子元素自动成为容器成员称为Flex项目。
<span class="token number">2</span>. 轴线
   Flex容器默认存在两根轴：水平的主轴以及垂直的交叉轴。项目默认沿着水平主轴排列。可以使用flex-direction来指定主轴的方向。可以使⽤justify-content来指定元素在主轴上的排列⽅式，使⽤align-items来指定元素在交叉轴上的排列⽅式。还可以使⽤flex-wrap来规定当⼀⾏排列不下时的换⾏⽅式。对于容器中的项⽬，可以使⽤order属性来指定项⽬的排列顺序，还可以使⽤flex-grow来指定当排列空间有剩余的时候，项⽬的放⼤⽐例，还可以使⽤flex-shrink来指定当排列空间不⾜时，项⽬的缩⼩⽐例
<span class="token number">3</span>. 容器属性
   flex-direction
   flex-wrap
   flex-flow
   *justify-content
   *align-items
   align-contents
<span class="token number">4</span>. 项目属性
   order      项目的排列顺序 数值越小越靠前
   flex-grow  定义放大比例
   *flex-shrink  定义缩小比例
   flex-basis    默认auto即本来大小
   *flex      grow<span class="token operator">|</span>shrink<span class="token operator">|</span>basis的缩写
   align-self

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="_3-为什么需要清除浮动"><a href="#_3-为什么需要清除浮动" class="header-anchor">#</a> 3. 为什么需要清除浮动？</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. html元素在普通流中的排列方式：
   自html中出现的先后顺序自上而下依次排列布局。行内元素水平排列直到当行被占满然后换行，块级元素则会被渲染为一整行
<span class="token number">2</span>. 浮动
   浮动使元素脱离文档普通流，漂浮在普通流之上。按照我们设置的浮动方向向左或向右浮动，当浮动元素的高度超出包含框（其实就是父元素）的高度时，父元素自然无法被撑开也不能包裹被浮动元素，即所谓“高度塌陷”
<span class="token number">3</span>. 清除浮动的方式
   给⽗级div定义 height 属性
   最后⼀个浮动元素之后添加⼀个空的div标签，并添加 clear:both 样式
   包含浮动元素的⽗级标签添加 overflow:hidden 或者 overflow:auto
   使⽤ :after 伪元素。由于IE6-7不⽀持 :after，使⽤ zoom:1 触发
   .clearfix:after<span class="token punctuation">{</span>
   		content:<span class="token string">&quot;&quot;</span>,
   		display: table<span class="token punctuation">;</span>
   		height: <span class="token number">0</span><span class="token punctuation">;</span>
   		clear: both<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   .clearfix<span class="token punctuation">{</span>
   		*zoom: <span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>通俗语言：清除浮动是清除浮动带来的负面影响。因为子元素浮动了，脱离了文档的标准流，导致无法撑开 没有设置高度的父元素。此时父元素高度为0，后续的结构直接跑上来占据了父元素所在位置。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_4-对bfc的理解-如何创建bfc"><a href="#_4-对bfc的理解-如何创建bfc" class="header-anchor">#</a> 4. 对<code>BFC</code>的理解 如何创建<code>BFC</code></h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>BFC:块级格式化上下文 是web页面中可视化css渲染的一部分，是布局中生成块级盒子的区域 也是浮动元素与其他元素的交互限定区域

通俗: BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定的规则摆放的物品，不会影响到其他容器中的物品。也就是说一个元素符合BFC的条件，则BFC中的元素布局不受外部影响
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>创建BFC的条件：
<span class="token number">1</span>. 根元素 body
<span class="token number">2</span>. 设置浮动  float为 left <span class="token operator">|</span> right 除了none
<span class="token number">3</span>. 设置定位  position为 absolute relative
<span class="token number">4</span>. overflow hidden <span class="token operator">|</span> scroll <span class="token operator">|</span> auto
<span class="token number">5</span>. display  flex <span class="token operator">|</span> inline-block等
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>特点：
<span class="token number">1</span>. 排列方向与普通文档流排列方向一致
<span class="token number">2</span>. 在BFC中上下相邻的每个容器的margin会重叠
<span class="token punctuation">..</span>.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>作用：
<span class="token number">1</span>. 解决margin的重叠问题。将上下两个盒子变为BFC区域就可以解决重叠
<span class="token number">2</span>. 解决高度塌陷的问题:子元素设置浮动之后，父元素会发生高度塌陷，也就是父元素的高度为0。此时只要父元素是BFC，常用overflow
<span class="token number">3</span>. 创建自适应两栏布局
   左侧浮动 右侧BFC 这样就不会重叠
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_5-position的属性有哪些-区别是什么"><a href="#_5-position的属性有哪些-区别是什么" class="header-anchor">#</a> 5. <code>position</code>的属性有哪些，区别是什么</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>属性：
<span class="token number">1</span>. absolute 绝对定位  相对static以外的一个父元素进行定位（ position:relative/absolute/fixed）
<span class="token number">2</span>. relative 相对定位  相对原来的位置进行定位
<span class="token number">3</span>. fixed    绝对定位  相对屏幕视口指定位置，在屏幕滚动时不会改变
<span class="token number">4</span>. static   默认      没有定位 元素出现在正常的文档流中
<span class="token number">5</span>. inherit  继承父元素position属性
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_6-实现一个三角形"><a href="#_6-实现一个三角形" class="header-anchor">#</a> 6. 实现一个三角形</h2> <p><img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230401194344283.png" alt="image-20230401194344283"></p> <p><img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230401194452900.png" alt="image-20230401194452900"></p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token comment">/*令其他三个角的背景都为透明*/</span>
<span class="token selector">div</span><span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span>
    <span class="token property">border-top</span><span class="token punctuation">:</span> 50px solid red<span class="token punctuation">;</span>
    <span class="token property">border-right</span><span class="token punctuation">:</span> 50px solid transparent<span class="token punctuation">;</span>
    <span class="token property">border-left</span><span class="token punctuation">:</span> 50px solid transparent<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
通过控制上下左右边框来控制三角形的方向。
用边框的宽度来控制三角形的角度
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_7-画一条0-5px的线"><a href="#_7-画一条0-5px的线" class="header-anchor">#</a> 7. 画一条0.5px的线</h2> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">div</span><span class="token punctuation">{</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
    <span class="token property">height</span><span class="token punctuation">:</span> 1px<span class="token punctuation">;</span>
    <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>0.5<span class="token punctuation">,</span>0.5<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_8-javascript有哪些数据类型-区别"><a href="#_8-javascript有哪些数据类型-区别" class="header-anchor">#</a> 8 JavaScript有哪些数据类型，区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. js的数据类型分为基本数据类型和引用数据类型
   基本数据类型： Number Boolean String Null undefined
   引用数据类型： Function Object Array
   还有Symbol BigInt 是ES6新增的数据类型
   <span class="token number">1.1</span> Symbol:创建后独一无二且不可变的数据类型，为解决全局变量冲突的问题
   <span class="token number">1.2</span> BigInt:数字类型的数据，可以表示任意精度的整数
   
<span class="token number">2</span>. 区别：存储位置的不同
   基本数据类型存储在 栈内存 中: 占据空间小 大小固定 使用频繁
   引用数据类型存储在 堆内存 中: 占据空间大 大小不固定 在栈内存中存储了指针，指向堆内存中该实体的起始位置
   
<span class="token number">3</span>. 对 堆 和 栈 的概念
   在数据结构中：栈中数据先进后出；堆是优先队列，按照优先级进行排序
   在操作系统中：栈中内存由编译器自动分配释放；堆由开发者进行分配释放，如果没有释放，那么程序结束后由垃圾回收机制回收
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="_9-数据类型检测的方式有哪些"><a href="#_9-数据类型检测的方式有哪些" class="header-anchor">#</a> 9 数据类型检测的⽅式有哪些</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. typeof 
   数组 对象 null 都会被判断为object
<span class="token number">2</span>. instanceof 可以正确判断对象的类型，内部运行机制是判断原型链中能否找到该类型的原型
   但是只能判断引用数据类型 不能判断基本数据类型
   可以用来测试一个对象在原型链中是否存在一个构造函数的prototype属性
   
<span class="token number">3</span>. contructor
   判断数据的类型  <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>.contructor <span class="token operator">==</span><span class="token operator">=</span> Array <span class="token boolean">true</span> 记得加括号
   对象实例通过 constructor 对象访问它的构造函数
   
<span class="token number">4</span>. Object.prototype.toString.call<span class="token punctuation">(</span><span class="token punctuation">)</span> 使用Object的原型方法来判断数据类型
   使用方法：Object.prototype.toString.call<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 输出<span class="token punctuation">[</span>object Array<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_10-判断数组的方式有哪些"><a href="#_10-判断数组的方式有哪些" class="header-anchor">#</a> 10 判断数组的方式有哪些</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 通过 Object.prototype.toString.call<span class="token punctuation">(</span><span class="token punctuation">)</span> 判断
<span class="token number">2</span>. 原型链 arr.__proto__ <span class="token operator">==</span><span class="token operator">=</span> Array.prototype
<span class="token number">3</span>. ES6的Array.isArray<span class="token punctuation">(</span><span class="token punctuation">)</span>  
<span class="token number">4</span>. instanceof  arr instanceof Array
<span class="token number">5</span>. Array.prototype.isPrototypeOf
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_11-null和undefined的区别"><a href="#_11-null和undefined的区别" class="header-anchor">#</a> 11 null和undefined的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 首先都是基本数据类型
<span class="token number">2</span>. undefined: 未定义 变量声明了但还没有定义会返回undefined
   null:空对象 赋值给一些可能会返回对象的变量作为初始化
<span class="token number">3</span>. null的类型会返回 Object   判断 <span class="token operator">==</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token operator">==</span><span class="token operator">=</span> <span class="token boolean">false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h1 id="_2023年4月2日-星期天"><a href="#_2023年4月2日-星期天" class="header-anchor">#</a> 2023年4月2日 星期天</h1> <h2 id="_1-typeof-null-的结果是什么-为什么"><a href="#_1-typeof-null-的结果是什么-为什么" class="header-anchor">#</a> 1. <code>typeof null</code> 的结果是什么，为什么？</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 结果是Object 毫无疑问
<span class="token number">2</span>. JavaScript第一个版本中 所有值都存储在32位的单元中 每个单元包含一个小的类型标签以及当前要存储值的真实数据。 类型标签存储在每个单元的低位中。五种数据类型：
   000 object
   001 int
   010 double
   <span class="token number">100</span> string
   <span class="token number">110</span> boolean
<span class="token number">3</span>. 有两种特殊数据类型
   undefined 超出整数范围的数字
   null 机器码null指针 （值全是0）
   也就是说null的类型标签也是000 和Object的类型标签一样
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_2-intanceof-操作符的实现原理及实现"><a href="#_2-intanceof-操作符的实现原理及实现" class="header-anchor">#</a> 2. <code>intanceof</code> 操作符的实现原理及实现</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. instanceof 用来检测引用数据类型，而无法检测基本数据类型
   arr instanceof Array
   
<span class="token number">2</span>. 原理是判断构造函数的prototype属性是否出现在对象的原型链中的任何位置
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myInstanceOf</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span>right</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 获取对象的原型</span>
    <span class="token keyword">let</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取构造函数的 prototype对象</span>
    <span class="token keyword">let</span> prototype <span class="token operator">=</span> right<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    <span class="token comment">// 判断构造函数的prototype对象是否在对象的原型上</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>proto<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>proto <span class="token operator">===</span> prototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果没有就继续从原型上找</span>
        proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="_3-为什么0-1-0-2-0-3-如何让其相等"><a href="#_3-为什么0-1-0-2-0-3-如何让其相等" class="header-anchor">#</a> 3. 为什么0.1+0.2 ! == 0.3，如何让其相等</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 计算机是通过二进制的方式存储数据的，在计算时实际上是计算的两个数的二进制的和
<span class="token number">2</span>. toFixed<span class="token punctuation">(</span>num<span class="token punctuation">)</span> 可以将Number四舍五入为指定小数位数的数字
<span class="token number">3</span>. 设置一个误差范围通常称为机器精度 对JavaScript来说这个值通常为2的-52次方。ES6提供了Number.EPSILON属性就是该值。
   只要判断 <span class="token number">0.1</span>+0.2-0.3 <span class="token operator">&lt;</span> Number.EPSILON 就可判定相等
   Math.abs<span class="token punctuation">(</span>arg1 - arg2<span class="token punctuation">)</span> <span class="token operator">&lt;</span> Number.EPSILON<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_4-操作符的强制类型转换规则"><a href="#_4-操作符的强制类型转换规则" class="header-anchor">#</a> 4. == 操作符的强制类型转换规则？</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 对于 <span class="token operator">==</span> 比较的双方而言 如果比较的类型不同 就会进行强制类型转换。
   感觉是优先转换为Number和原始类型
   
<span class="token number">2</span>. 判断流程
   <span class="token number">1</span>. 首先判断类型是否相同 相同就比较两者大小
      <span class="token number">1.1</span> 先判断是否为null <span class="token operator">==</span> undefined 是返回true
      <span class="token number">1.2</span> string <span class="token operator">==</span> number  将字符串转换为数字类型
      <span class="token number">1.3</span> 有boolean比较 就转换为数字
      <span class="token number">1.4</span> object <span class="token operator">==</span> string <span class="token operator">|</span> number <span class="token operator">|</span> symbol 将对象转换为原始
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_5-object-is-与比较操作符-、-的区别"><a href="#_5-object-is-与比较操作符-、-的区别" class="header-anchor">#</a> 5. <code>Object.is()</code> 与⽐较操作符 “ === ”、“ == ” 的区别？</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. <span class="token operator">==</span> 进行比较相等判断时，如果双方类型不同会进行强制类型转换后再对比
<span class="token number">2</span>. <span class="token operator">==</span><span class="token operator">=</span> 如果类型不同 不会强制 需要类型相同且大小相等才返回true
<span class="token number">3</span>. Object.is<span class="token punctuation">(</span><span class="token punctuation">)</span>在 <span class="token operator">==</span><span class="token operator">=</span> 的基础上处理一些特殊情况 如 <span class="token parameter variable">-0</span> ≠ +0 NaN <span class="token operator">==</span><span class="token operator">=</span> NaN
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_6-new操作符的实现原理"><a href="#_6-new操作符的实现原理" class="header-anchor">#</a> 6. <code>new</code>操作符的实现原理</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 首先创建一个空对象
<span class="token number">2</span>. 让这个空对象的原型指向函数的prototype
<span class="token number">3</span>. 让这个函数的this指向这个对象
<span class="token number">4</span>. 判断返回类型 如果是值类型 就返回创建的对象 如果是引用类型 就返回该引用类型
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">creatNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token punctuation">[</span>contructor<span class="token punctuation">,</span><span class="token operator">...</span>args<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> contructor<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">?</span> result <span class="token operator">:</span> obj<span class="token punctuation">;</span><span class="token comment">// ?</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_7-数组有哪些原生方法"><a href="#_7-数组有哪些原生方法" class="header-anchor">#</a> 7. 数组有哪些原⽣⽅法</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>字符串操作
<span class="token number">1</span>. toString<span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>.toString<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token string">'1,2,3'</span>
<span class="token number">2</span>. toLocalString<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">3</span>. join<span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>.join<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token string">'1 2 3'</span>

尾部操作
<span class="token number">1</span>. pop<span class="token punctuation">(</span><span class="token punctuation">)</span>              <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>.pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">3</span>  返回尾部删除的元素
<span class="token number">2</span>. push<span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>.push<span class="token punctuation">(</span><span class="token number">8,9</span><span class="token punctuation">)</span>   <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">5</span> 返回最新长度

首部操作
<span class="token number">1</span>. shift<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>.shift<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">1</span> 返回首部删除的元素
<span class="token number">2</span>. unshift<span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>.unshift<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">4</span> 返回最新长度
<span class="token number">3</span>. reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>.reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">3,2</span>,1<span class="token punctuation">]</span> 会改变原来数组
<span class="token number">4</span>. sort<span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token punctuation">[</span><span class="token number">3,2</span>,1<span class="token punctuation">]</span>.sort<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span> 会改变原来数组

其他
<span class="token number">1</span>. concat<span class="token punctuation">(</span><span class="token punctuation">)</span> 数组间的拼接             <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>.concat<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">9,8</span>,7<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span>, <span class="token number">2</span>, <span class="token number">3</span>, <span class="token number">9</span>, <span class="token number">8</span>, <span class="token number">7</span><span class="token punctuation">]</span> 不改变原来数组
<span class="token number">2</span>. slice<span class="token punctuation">(</span><span class="token punctuation">)</span>  截取一部分<span class="token punctuation">[</span>start,end<span class="token punctuation">]</span>    <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>.slice<span class="token punctuation">(</span><span class="token number">0,1</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> 不改变原来数组 返回被截取部分
<span class="token number">3</span>. splice<span class="token punctuation">(</span><span class="token punctuation">)</span> 截取一部分再添加数据<span class="token punctuation">[</span>index,delCount,<span class="token punctuation">..</span>.addItems<span class="token punctuation">]</span>
                                    <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>.splice<span class="token punctuation">(</span><span class="token number">0,1</span>,8,9<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> 改变原数组 返回被截取部分
<span class="token number">4</span>. indexOf<span class="token punctuation">(</span><span class="token punctuation">)</span> 查看元素所在的索引      <span class="token punctuation">[</span><span class="token number">8,9</span>,2,3<span class="token punctuation">]</span>.indexOf<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">1</span>  从左往右第一个符合的元素
<span class="token number">5</span>. lastIndexOf<span class="token punctuation">(</span><span class="token punctuation">)</span> 从右往左第一个符合的元素
<span class="token number">6</span>. every<span class="token punctuation">(</span><span class="token punctuation">)</span> some<span class="token punctuation">(</span><span class="token punctuation">)</span> map<span class="token punctuation">(</span><span class="token punctuation">)</span> forEach<span class="token punctuation">(</span><span class="token punctuation">)</span>
   every 测试一个数组内的所有元素是否都能通过指定函数的测试。它返回一个布尔值。
   some<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法测试数组中是不是至少有 <span class="token number">1</span> 个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。
   map<span class="token punctuation">(</span><span class="token punctuation">)</span> 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。
归并
<span class="token number">1</span>. reduce<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">2</span>. ruduceRight<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank" rel="noopener noreferrer">Array.prototype.every() - JavaScript | MDN (mozilla.org)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener noreferrer">Array.prototype.map() - JavaScript | MDN (mozilla.org)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="noopener noreferrer">Array.prototype.some() - JavaScript | MDN (mozilla.org)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_8-什么是-dom-和-bom"><a href="#_8-什么是-dom-和-bom" class="header-anchor">#</a> 8 什么是 DOM 和 BOM？</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. DOM 文档对象模型，将文档当做一个对象 主要定义处理网页的方法和接口。dom的顶级对象是document

<span class="token number">2</span>. BOM 浏览器对象模型，将浏览器当做一个对象 主要定义与浏览器交互的方法与接口。bom的顶级对象是window

<span class="token number">3</span>. dom的顶级对象是bom的顶级对象的子对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_9-对类数组对象的理解-如何转化为数组"><a href="#_9-对类数组对象的理解-如何转化为数组" class="header-anchor">#</a> 9 对类数组对象的理解，如何转化为数组</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 概念
   拥有length属性和若干索引属性的对象就称为类数组对象，与数组类似 但不能调用数组方法
   常见：arguments和Dom方法的返回结果 函数参数也可以看做类数组对象
<span class="token number">2</span>. 方法
   Array.from<span class="token punctuation">(</span><span class="token punctuation">)</span>
   调用数组的slice splice concat
   Array.prototype.slice.call<span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span>
   Array.prototype.splice.call<span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span>
   Array.prototype.concat.call<span class="token punctuation">(</span>arrayLike<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_10-对ajax的理解-实现一个ajax请求"><a href="#_10-对ajax的理解-实现一个ajax请求" class="header-anchor">#</a> 10 对<code>AJAX</code>的理解，实现⼀个<code>AJAX</code>请求</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>Ajax指的是通过JavaScript的异步通信 从服务器获取XML文档从中提取数据 再更新当前网页的对应部分 而不用刷新整个网页
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_11-javascript为什么要进行变量提升-它导致了什么问题"><a href="#_11-javascript为什么要进行变量提升-它导致了什么问题" class="header-anchor">#</a> 11 JavaScript为什么要进⾏变量提升，它导致了什么问题？</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 变量提升：
   无论在函数中何处位置声明的变量 都被提升到了函数的首部，可以在变量声明前访问而不会报错
   
<span class="token number">2</span>. 本质原因：js引擎在代码执行前会有一个解析的过程 创建了执行上下文 初始化一些代码执行过程中需要用到的对象。当访问到一个变量时，就去当前执行上下文的作用域链中寻找 而作用域链的首端指的是当前执行上下文的变量对象 这个变量对象是其中一个属性 包含了函数的形参 所有函数以及变量的声明 这个对象在代码解析的时候创建的。

<span class="token number">3</span>. 全局上下文：变量定义 函数声明
   函数上下文：变量定义 函数声明 this arguments
   解析和执行：
   <span class="token number">3.1</span> 解析时创建一个上下文 把要执行的变量 函数声明都拿出来 变量赋值为undefined 函数先声明
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>为什么进行变量提升呢？也就是说变量提升的好处
<span class="token number">1</span>. 容错性更好！
   如果在声明前使用了也不会报错，只会输出undefined，使一些不规范的代码也能正常运行
<span class="token number">2</span>. 提高性能
   JS执行之前 要先进行语法检查和预编译 <span class="token operator">==</span><span class="token operator">&gt;</span> 避免每次执行前都要解析一遍变量或函数 <span class="token operator">==</span><span class="token operator">&gt;</span> 提高性能
   解析和预编译过程中的声明提升可以提⾼性能，让函数可以在执⾏时预先为变量分配栈空间
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 前提：ES6中提出的let const定义变量 就没有变量提升的机制
导致的问题：
   重复声明 函数内容的变量会覆盖掉外部的变量
   循环变量定义的 i 会变量提升为全局变量 函数结束后也不会销毁
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h1 id="_2023年4月3日-星期一"><a href="#_2023年4月3日-星期一" class="header-anchor">#</a> 2023年4月3日 星期一</h1> <h2 id="_1-let-const-var的区别"><a href="#_1-let-const-var的区别" class="header-anchor">#</a> 1. <code>let</code> <code>const</code> <code>var</code>的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. <span class="token builtin class-name">let</span> const 存在块级作用域 var没有
   解决了：内层变量可能覆盖外层变量；用来计数的循环变量泄露为全局变量
<span class="token number">2</span>. var存在变量提升
<span class="token number">3</span>. var声明的变量会自动变为全局变量，并且该变量会被添加全局对象的属性。浏览器中可以使用window.name访问到
<span class="token number">4</span>. 重复声明 var允许重复 后声明会覆盖前声明
<span class="token number">5</span>. 暂时性死区 在使用let const 声明变量之前 该变量都是不可用的
<span class="token number">6</span>. 初始值设置 <span class="token builtin class-name">let</span> var可以不用设置 但是const一定要设置
<span class="token number">7</span>. 指针指向 let可以重新赋值 const不可用
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_2-箭头函数与普通函数的区别"><a href="#_2-箭头函数与普通函数的区别" class="header-anchor">#</a> 2. 箭头函数与普通函数的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 更加简洁
   如果没有参数 直接写空括号
   如果有一个参数 省去括号
   如果有多个参数 括号加逗号隔开
   如果返回值只有一句 可以省略大括号
   不需要返回值 <span class="token builtin class-name">let</span> fn <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> void doesNotReturn<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 调用一个函数 箭头函数本身没有返回值
<span class="token number">2</span>. 箭头函数没有自己的this，在作用域的上一层继承this
<span class="token number">3</span>. 箭头函数继承来的this指向永远不会改变 call <span class="token builtin class-name">bind</span> apply 都不能改变箭头函数的方向
<span class="token number">4</span>. 箭头函数不能作为构造函数使用 即不可以new 因为new会改变函数的指向 但不能
<span class="token number">5</span>. 箭头函数没有自己的arguments 访问会得到上一层的arguments
<span class="token number">6</span>. 没有prototype
<span class="token number">7</span>. 不能用作Generator函数 不能使用yeild
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_3-const对象的属性可以修改吗"><a href="#_3-const对象的属性可以修改吗" class="header-anchor">#</a> 3. <code>const</code>对象的属性可以修改吗</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. const保证的并不是变量的值不能改动 而是变量指向的那个内存地址不能改动。
<span class="token number">2</span>. 如果定义的是基本数据类型 值是不能改动的
<span class="token number">3</span>. 如果是引用类型的数据（对象+数组） 变量指向数据的内存地址 保存的只是一个指针 const保证指针不变 但是指向的数据结构怎么 它是不管的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_4-扩展运算符"><a href="#_4-扩展运算符" class="header-anchor">#</a> 4.  扩展运算符</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 对象扩展运算符 <span class="token punctuation">..</span>. 用于取出参数对象中的所有可遍历属性 拷贝到当前对象之中
<span class="token builtin class-name">let</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span> a: <span class="token number">1</span>, b: <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span><span class="token punctuation">..</span>.bar<span class="token punctuation">}</span> <span class="token operator">==</span><span class="token operator">=</span> Object.assign<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span>, bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">2</span>. Object.assign<span class="token punctuation">(</span>target,source<span class="token punctuation">)</span> 将source的所有可枚举属性复制到目标对象target上，可以有多个源对象。源对象中同名属性会覆盖掉前面的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 数组扩展运算符 <span class="token punctuation">..</span>. 可以将一个数组转为用逗号分隔的参数序列 每次只能展开一层
<span class="token punctuation">..</span>.<span class="token punctuation">[</span><span class="token number">1,2</span>,<span class="token punctuation">[</span><span class="token number">3,4</span><span class="token punctuation">]</span>,5<span class="token punctuation">]</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token number">2</span>  <span class="token punctuation">[</span><span class="token number">3</span>, <span class="token number">4</span><span class="token punctuation">]</span> <span class="token number">5</span>
<span class="token number">2</span>. 将数组转化为参数序列
add<span class="token punctuation">(</span><span class="token punctuation">..</span>.numbers<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">&gt;</span> add<span class="token punctuation">(</span><span class="token number">1,2</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">&gt;</span> <span class="token number">3</span>
<span class="token number">3</span>. 复制数组:可以取出参数对象中的所有可遍历属性 拷贝到当前对象中
arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">..</span>.arr1<span class="token punctuation">]</span>
<span class="token number">4</span>. 数组内合并数组
arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'one'</span>, <span class="token punctuation">..</span>.arr1, <span class="token string">'four'</span><span class="token punctuation">]</span>
<span class="token number">5</span>. 扩展运算符与解构赋值结合 用来生成数组 【扩展运算符只能放在参数最后一位】
const <span class="token punctuation">[</span>first, <span class="token punctuation">..</span>.rest<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1,2</span>,3,4,5<span class="token punctuation">]</span>
<span class="token number">6</span>. 将字符串转为真正的数组
<span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token string">'hello'</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>嵌套解构
const school <span class="token operator">=</span> <span class="token punctuation">{</span>
	classes:<span class="token punctuation">{</span>
		stu:<span class="token punctuation">{</span>
			name: <span class="token string">'Bob'</span>,
			age: <span class="token number">23</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
获取到 name <span class="token builtin class-name">:</span>
const <span class="token punctuation">{</span> classes: <span class="token punctuation">{</span>stu: <span class="token punctuation">{</span> name <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">=</span> school
<span class="token operator">==</span><span class="token operator">&gt;</span> 解构出classes里面的stu里面的name
可以在解构出来的变量名右侧通过冒号+<span class="token punctuation">{</span>目标属性名<span class="token punctuation">}</span>这种形式进一步解构它 一直解构到拿到目标数据为止
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_5-对rest参数的理解"><a href="#_5-对rest参数的理解" class="header-anchor">#</a> 5. 对<code>rest</code>参数的理解</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. reset【<span class="token punctuation">..</span>.】运算符可以将分离的参数序列整合成一个数组
   用于获取函数的多余参数 也可以处理函数参数个数不确定的情况
函数声明：
<span class="token keyword">function</span> mutiple<span class="token punctuation">(</span><span class="token punctuation">..</span>.args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
mutiple<span class="token punctuation">(</span><span class="token number">1,2</span>,3,4<span class="token punctuation">)</span>      <span class="token comment"># 传入的是参数序列 但是args变为数组</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_6-es6的模板语法与字符串处理"><a href="#_6-es6的模板语法与字符串处理" class="header-anchor">#</a> 6. ES6的模板语法与字符串处理</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 模板语法：拼接字符串 【``】
   <span class="token number">1.1</span> 允许使用 $<span class="token punctuation">{</span><span class="token punctuation">}</span> 的方式嵌入变量
   <span class="token number">1.2</span> 在模板字符串中 空格 缩进 换行都会保留
   <span class="token number">1.3</span> 可以在$<span class="token punctuation">{</span><span class="token punctuation">}</span>中完成计算
   
<span class="token number">2</span>. 存在性判定：判断一个字符/串是否在某字符串中<span class="token punctuation">;</span>返回布尔值
   <span class="token number">2.1</span> includes 
   <span class="token number">2.2</span> startsWith
   <span class="token number">2.3</span> endsWith
   
<span class="token number">3</span>. repeat 使同一个字符串输出多次 连续复制
   arr.repeat<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_7-对象与数组解构"><a href="#_7-对象与数组解构" class="header-anchor">#</a> 7 对象与数组解构</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 解构是ES6提供的一种新的提取数据的模式 可以针对性地拿到数组或对象中想要的数据
<span class="token number">2</span>. 数组解构：以元素的位置为匹配条件
   const <span class="token punctuation">[</span>a,,c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>  <span class="token operator">==</span><span class="token operator">&gt;</span>  <span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token number">3</span>
<span class="token number">3</span>. 对象解构 以属性的名称为匹配条件 来提取需要的数据的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h1 id="_2023年4月4日-星期二"><a href="#_2023年4月4日-星期二" class="header-anchor">#</a> 2023年4月4日 星期二</h1> <h2 id="_1-对原型和原型链的理解"><a href="#_1-对原型和原型链的理解" class="header-anchor">#</a> 1 对原型和原型链的理解</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 在JavaScript中 是使用构造函数来新建对象的。每个构造函数内部都有一个prototype属性 该属性值是一个对象 这个对象包含了所有由该构造函数创建的实例共享的属性和方法。在该实例内部也包含一个指针 指向该构造函数的prototype属性的值 这个指针就被称为原型

注意:  现在浏览器中都实现了 __proto__ 属性来访问这个对象属性，但是最好不要使用 因为它不是规范中规定的。 ES5新增了 Object.getPrototypeOf<span class="token punctuation">(</span><span class="token punctuation">)</span>方法来获取实例对象的原型 即构造函数的prototype属性
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">2</span>. 当访问一个对象的属性的时候 当这个对象本身内部并不存在这个属性时 就会去它的原型对象中寻找 也没有就去原型对象的原型中寻找 就一直找下去 就是原型链的概念。

注意：一般原型链的尽头是 Object.prototype 
     JavaScript对象是通过引用来传递的 创建的每个新对象实体中并有属于自己的原型副本 但修改原型时 与之相关的也会继承该改变
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_2-原型链的终点"><a href="#_2-原型链的终点" class="header-anchor">#</a> 2. 原型链的终点</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>原型链上所有原型都是对象。终点是 Object.prototype.__proto__ 是null 所有的对象最终都是有Object构成的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_3-获取对象非原型链上的属性"><a href="#_3-获取对象非原型链上的属性" class="header-anchor">#</a> 3. 获取对象非原型链上的属性</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 判断是否属于原型链上
   obj.hasOwnProperty<span class="token punctuation">(</span>item<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">iterate</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key<span class="token operator">+</span><span class="token string">':'</span><span class="token operator">+</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_4-对闭包的理解"><a href="#_4-对闭包的理解" class="header-anchor">#</a> 4. 对闭包的理解</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 闭包是指有权访问另一个函数作用域中变量的函数
<span class="token number">2</span>. 创建闭包：在一个函数内创建另一个函数 创建的函数可以访问到当前函数的局部变量
<span class="token number">3</span>. 在JS中 闭包存在的意义就是让我们间接访问函数内部的变量
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    window<span class="token punctuation">.</span><span class="token function-variable function">B</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 函数B可以访问到函数A中的变量 函数B就是闭包</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>闭包常用用途：
<span class="token number">1</span>. 使我们在函数外部可以访问到函数内部的变量。调用执行B函数，就可以获取到A函数中的私有变量。
<span class="token number">2</span>. 使已经运行结束的函数上下文的变量对象继续留在内存中,A函数已经运行完毕 但其中的变量a还被B函数进行引用 闭包函数保留了这个变量对象的引用 不会被回收
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="经典面试题-循环中使用闭包解决var定义"><a href="#经典面试题-循环中使用闭包解决var定义" class="header-anchor">#</a> 经典面试题：循环中使用闭包解决<code>var</code>定义</h3> <h2 id="_5-对作用域-作用域链的理解"><a href="#_5-对作用域-作用域链的理解" class="header-anchor">#</a> 5. 对作用域 作用域链的理解</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 全局作用域：最外层函数 最外层函数外面定义的变量 未定义直接赋值的变量 window对象的属性 
   弊端：过多的全局作用域变量会污染全局命名空间 容易引起命名冲突
<span class="token number">2</span>. 函数作用域：声明在函数内部的变量 内层作用域可以访问外层作用域

<span class="token number">3</span>. 块级作用域：let 和 const 声明 由 <span class="token punctuation">{</span> <span class="token punctuation">}</span> 包裹的代码片段
              不会有变量提升 也不可以重复声明
              在循环中比较适合绑定块级作用域 声明的计数器可以限制在循环内部
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>作用域链
<span class="token number">1</span>. 在当前作用域中查找所需变量 如果没有这个变量 就去父级作用域中查找 依次向上级作用域查找 直到访问到window对象就终止 这一层层的关系就是作用域链
<span class="token number">2</span>. 作用是保证对执行环境有权访问的所有变量和函数的有序访问 通过作用域链 可以访问外层环境的变量和函数
<span class="token number">3</span>. 本质上是一个指向变量对象的指针列表 作用域链的前端都是当前执行上下文的变量对象 全局执行上下文的变量对象是作用域链的最后一个对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_6-对执行上下文的理解"><a href="#_6-对执行上下文的理解" class="header-anchor">#</a> 6. 对执行上下文的理解</h2> <h3 id="执行上下文"><a href="#执行上下文" class="header-anchor">#</a> 执行上下文</h3> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. javascript引擎并非一行一行地分析与执行 而是一段一段地分析执行
<span class="token number">2</span>. 到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？
   可执行代码包括 全局代码 函数代码 eval代码
   当执行到一个函数时 就会进行准备工作 换个专业说法为 执行上下文
   
注意是：执行一个函数的时候 才会创建一个执行上下文
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="执行上下文栈"><a href="#执行上下文栈" class="header-anchor">#</a> 执行上下文栈</h3> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 一个JavaScript文件中 写的函数多了去 那么怎么管理那么多的执行上下文呢
<span class="token number">2</span>. 所以javascript引擎创建了执行上下文栈来管理执行上下文
   初始化的时候 栈底就是 创建的全局执行上下文 是将代码中即将执行的变量 函数声明都拿出来 变量赋值为undefined 函数先声明后使用
   每当遇到一个函数调用 就会创建一个新的执行上下文 引擎会执行栈顶的函数 执行完成之后 才会从栈中弹出 当所有代码都执行完毕之后 才会弹出全局执行上下文
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h1 id="_2023年4月5日-星期三"><a href="#_2023年4月5日-星期三" class="header-anchor">#</a> 2023年4月5日 星期三</h1> <h2 id="_1-异步编程实现方式"><a href="#_1-异步编程实现方式" class="header-anchor">#</a> 1 异步编程实现方式</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>javascript的异步机制：
<span class="token number">1</span>. 回调函数
   缺点：多个回调嵌套会导致回调地狱 代码耦合度太高 不利于维护
<span class="token number">2</span>. Promise：可以将嵌套的回调作为链式调用
   缺点：有时多个then的链式调用 会造成代码语义不够明确
<span class="token number">3</span>. generator：将函数的执行权转移出去 在函数外部再转移出来
   需要考虑何时将函数的控制权转移出来
<span class="token number">4</span>. async：是generator和Promise实现的一个自动执行的语法糖
   当函数内部执行一个await语句时 如果返回的是Promise对象 那么函数将会等待Promise对象的状态变为resolve后再往下执行。
   可以将异步逻辑转换为同步的顺序来书写 并且这个函数可以自动执行
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_2-settimeout-promise-async-await的区别"><a href="#_2-settimeout-promise-async-await的区别" class="header-anchor">#</a> 2 <code>setTimeout promise Async/Await</code>的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>setTimeout是异步任务中的宏任务
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>promise本身是同步的立即执行函数 当在executor中执行resolve和reject时 此时是异步操作 会先执行then、catch等
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>async函数需要等待 await 后的函数的执行完成并且有了返回结果之后 才能继续执行下面的代码 await通过返回一个promise对象来实现相同的效果
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_3-浏览器的垃圾回收机制"><a href="#_3-浏览器的垃圾回收机制" class="header-anchor">#</a> 3 浏览器的垃圾回收机制</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 垃圾回收
   JavaScript代码运行的时候 需要分配内存空间来存储变量和值。当变量不在参与运行时 就会被系统收回被占用的内存空间 就是垃圾回收

回收机制：
    <span class="token number">1</span>. JavaScript具有自动回收机制
    <span class="token number">2</span>. JavaScript存在两种变量 局部变量和全局变量
       全局变量持续要页面卸载
       局部变量在函数执行结束之后不再使用就会被释放
    <span class="token number">3</span>. 当然还有闭包这种情况
       尽管函数执行结束了 函数外部的变量依旧指向函数内部的局部变量 此时局部变量依然再被使用 所以不会回收
       
回收方式
    <span class="token number">1</span>. 标记清除：常见的垃圾回收方式
    <span class="token number">2</span>. 引用计数
       造成循环引用的问题 两个属性相互引用 引用次数为2 但是函数执行结束之后 引用次数还存在 不会被回收 需要手动进行回收

减少垃圾回收
    当代码比较复杂时 垃圾回收带来的代价就比较大 所以此刻要减少垃圾回收
    <span class="token number">1</span>. 对数组进行优化  长度设置为0
    <span class="token number">2</span>. 对Object进行优化  设置为null 尽快被回收
    <span class="token number">3</span>. 对函数进行优化  可以复用的表达式 尽量放在函数外面
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="_4-哪些情况会导致内存泄露"><a href="#_4-哪些情况会导致内存泄露" class="header-anchor">#</a> 4 哪些情况会导致内存泄露</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 意外的全局变量
<span class="token number">2</span>. 被遗忘的计时器或回调函数 
<span class="token number">3</span>. 脱离Dom的引用 获取到的Dom元素的引用 后来这个元素被删除了 但这个引用保留着 那就无法被回收
<span class="token number">4</span>. 闭包：可能导致某些变量一直被留在内存当中
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_5-get-post请求的区别"><a href="#_5-get-post请求的区别" class="header-anchor">#</a> 5 <code>GET POST</code>请求的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 幂等：
   一个 HTTP 方法是 幂等 的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>GET和POST是HTTP请求的两种方法
<span class="token number">1</span>. GET请求是幂等的请求 一般用于不会对服务器资源产生影响的场景
   POST请求不是幂等的 一般用于服务器资源产生影响的情景 比如注册
   总之：get一般用于搜索排序和筛选之类的操作 主要是获取资源 读取数据
        post用于修改和写入创建数据

<span class="token number">2</span>. GET请求可以将请求的参数放入到URL中向服务器发送 这样的做法相对POST是不太安全的 因为请求的URL会被保留在历史记录中

<span class="token number">3</span>. 一般浏览器会对GET请求进行缓存 很少对POST请求进行缓存

<span class="token number">4</span>. GET请求的报文中实体部分为空 但POST请求的报文中实体部分多为向浏览器发送的请求参数

 <span class="token number">5</span>. GET请求由于浏览器对URL的限制 会被限制发送数据的长度 而且只能发送ASCII字符
   POST请求就能发送的数据更大，也支持更多的数据类型
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="_6-常见的http请求方法"><a href="#_6-常见的http请求方法" class="header-anchor">#</a> 6 常见的<code>HTTP</code>请求方法</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. GET: 向服务器获取数据
<span class="token number">2</span>. POST: 将实体提交到指定的资源 通常会造成服务器资源的修改 相比PUT可以创建数据
<span class="token number">3</span>. PUT: 上传文件 更新数据
<span class="token number">4</span>. DELETE: 删除服务器上的对象

<span class="token number">5</span>. HEAD: 获取报文首部 与GET相比不返回报文主体内容
<span class="token number">6</span>. OPTIONS: 询问支持的请求方法 用来跨域请求
<span class="token number">7</span>. CONNECT: 要求在与代理服务器通信时建立隧道 使用隧道进行TCP通信
<span class="token number">8</span>. TRACE: 请求服务器回显其收到的请求信息 该方法用于HTTP请求的测试或诊断
<span class="token number">9</span>. PATCH: 与PUT相似 用于资源的更新 区别在与部分更新 PUT是总体更新 PUT是幂等的 PATCH不是
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><a href="https://juejin.cn/post/7101226255055323167#heading-7" target="_blank" rel="noopener noreferrer">HTTP常见请求方法小结 - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_7-http1-0-与-http1-1之间有哪些区别"><a href="#_7-http1-0-与-http1-1之间有哪些区别" class="header-anchor">#</a> 7 <code>HTTP1.0</code> 与 <code>HTTP1.1</code>之间有哪些区别?</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 连接方面：
   <span class="token number">1.0</span>采取非持久连接：每次发起HTTP请求都要与服务器建立TCP连接 服务器完成处理之后就会马上断开这个TCP连接
   <span class="token number">1.1</span>采取持久连接：可以复用这个TCP连接 以此来避免使用非持久连接时每次需要建立连接的时延
<span class="token number">2</span>. 资源请求方面
   <span class="token number">1.0</span>中存在带宽浪费的现象 客户端只需要对象中的一部分，但服务器却把整个对象发送过来 并且不支持断点续传
   <span class="token number">1.1</span>在请求头引入了range头域 允许只请求资源的一部分
<span class="token number">3</span>. 缓存方面
   <span class="token number">1.0</span>主要使⽤ header ⾥的 If-Modified-Since、Expires 来做为缓存判断的标准
   <span class="token number">1.1</span>则引⼊了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
<span class="token number">4</span>. HTTP1.1新增了host字段
<span class="token number">5</span>. HTTP1.1还新增了5种请求方法：OPTIONS PUT DELETE TRACE CONNECT
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_8-http1-1和http2-0的区别"><a href="#_8-http1-1和http2-0的区别" class="header-anchor">#</a> 8 <code>HTTP1.1</code>和<code>HTTP2.0</code>的区别</h2> <h2 id="_9-http和https协议的区别"><a href="#_9-http和https协议的区别" class="header-anchor">#</a> 9 <code>http</code>和<code>https</code>协议的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. https需要CA证书 费用较高 http不需要
<span class="token number">2</span>. http是超文本传输协议 信息是明文传输的 https则是具有安全性的SSL加密传输协议
<span class="token number">3</span>. http协议端口是80 HTTPS协议端口是 <span class="token number">443</span>
<span class="token number">4</span>. http协议连接很简单 是无状态的 https协议是有ssl和http协议构建的可进行加密传输 身份认证的网络协议 比http更加安全
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_10-当键入网址后-到网页显示-其间发生了什么"><a href="#_10-当键入网址后-到网页显示-其间发生了什么" class="header-anchor">#</a> 10 当键入网址后，到网页显示，其间发生了什么</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 解析URL
   URL元素组成：http: + // + web服务器 + 路径
   URL实际上是请求服务器里的文件资源。
   然后根据web服务器和文件名来生成http请求信息
   
<span class="token number">2</span>. 缓存判断： 浏览器 <span class="token operator">==</span><span class="token operator">&gt;</span> 操作系统 <span class="token operator">==</span><span class="token operator">&gt;</span> hosts文件
   浏览器会先看自身有没有关于这个域名的缓存 如果有 就直接返回 
   如果没有 就去问操作系统 操作系统也查看自己的缓存 如果有 就直接返回 
   如果没有 就去hosts文件看 如果没有 才会去问 本地DNS服务器
   
<span class="token number">3</span>. DNS解析
   生成http消息之后 需要委托操作系统将消息发送给web服务器，那么就需要查询服务器域名对应的ip地址 因为委托操作系统发送消息时 必须提供通信对象的ip地址
   DNS服务器专门保存了web服务器域名与IP的对应关系，包括根DNS服务器 顶级域DNS服务器 权威DNS服务器
   
<span class="token number">4</span>. 获取MAC地址
<span class="token number">5</span>. TCP三次握手
<span class="token number">6</span>. HTTPS握手
<span class="token number">7</span>. 返回数据
<span class="token number">8</span>. 页面渲染
<span class="token number">9</span>. TCP四次挥手
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>域名解析的工作流程（DNS完整的查询过程）
首先：任何DNS服务器都可以找到并访问根域DNS服务器
<span class="token number">1</span>. 客户端发出一个DNS请求 发送给本地的DNS服务器
<span class="token number">2</span>. 本地域名服务器 先去缓存中找 找不到就去访问根域DNS服务器
<span class="token number">3</span>. 根DNS收到本地DNS请求 会返回一个顶级域名服务器的地址
<span class="token number">4</span>. 本地DNS收到之后 就去访问顶级域名服务器
<span class="token number">5</span>. 顶级域名服务器收到本地DNS请求 会返回一个权威DNS服务器的地址
<span class="token number">6</span>. 本地DNS收到之后 就去访问权威域名服务器 会返回一个IP地址
<span class="token number">7</span>. 本地DNS收到 就将IP地址返回给客户端 客户端和目标建立连接
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/6.jpg" alt="域名解析的工作流程"></p> <h1 id="_2023年4月7日-星期五"><a href="#_2023年4月7日-星期五" class="header-anchor">#</a> 2023年4月7日 星期五</h1> <h2 id="_1-http的请求报文和响应报文"><a href="#_1-http的请求报文和响应报文" class="header-anchor">#</a> 1 <code>HTTP</code>的请求报文和响应报文</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>请求报文包括：
<span class="token number">1</span>. 请求行：请求方法（POST GET<span class="token punctuation">..</span>.） url 协议版本（HTTP/1.1）等
<span class="token number">2</span>. 请求头部
<span class="token number">3</span>. 空行
<span class="token number">4</span>. 请求体：POST GET等请求携带的数据
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>响应报文包括
<span class="token number">1</span>. 响应行：网络协议版本（HTTP/1.1）状态码（200 <span class="token number">206</span>等）原因短语（OK）
<span class="token number">2</span>. 响应头 
<span class="token number">3</span>. 空行
<span class="token number">4</span>. 响应体：服务器响应的数据
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_2-什么是https协议"><a href="#_2-什么是https协议" class="header-anchor">#</a> 2 什么是<code>https</code>协议</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. HTTP: 超文本传输协议
<span class="token number">2</span>. HTTPS: 超文本传输安全协议：经由HTTP进行通信 利用SSL/TLS来加密数据包 提供对网站服务器的身份认证和保护交换数据的隐私与完整性
在网络层的下面 TCP的上面加入一层安全层 SSL/TLS
安全层的职责：对发起的HTTP请求的数据进行加密操作和对接收到的HTTP内容进行解密操作
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_3-tls-ssl的工作原理"><a href="#_3-tls-ssl的工作原理" class="header-anchor">#</a> 3 <code>TLS/SSL</code>的工作原理</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>TLS/SSL：安全传输协议 是介于HTTP与TCP之间的一层的安全协议 
         主要依赖三类算法：散列函数hash 对称加密 非对称加密
散列函数：保证完整性
对称加密：信息加密
非对称加密：身份认证 密钥协商
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>概念：
<span class="token number">1</span>. 对称加密：通信双方都使用同一个密钥进行加解密 虽然简单 性能也好 但是无法解决首次发送密钥的时候 容易被拦截
<span class="token number">2</span>. 非对称加密：私钥+公钥
   使用私钥进行加密 对应的公钥才能解密 使用公钥解密 对应的私钥才能解密
   通信双方都有一套自己的密钥对 通信之前会发送公钥给对方
   虽然安全性高 但速度慢影响性能
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_4-https是怎么保证安全的"><a href="#_4-https是怎么保证安全的" class="header-anchor">#</a> 4 <code>HTTPS</code>是怎么保证安全的</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>对称加密与非对称加密各有优缺
解决方案：
    结合两种加密方式 将对称加密的密钥使用非对称加密的公钥进行加密 然后发送出去 接收方使用私钥进行解密 得到对称加密的密钥 然后使用对称加密进行沟通
    在这之前 还是要像非对称加密将公钥发给对方的
    为防止被中间人篡改公钥 需要一个安全的CA证书 为了证明身份。证书会包括使用者的公钥 私钥 HASH算法等 以及数字签名（为了得到中间是否被篡改）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_5-常见的http状态码"><a href="#_5-常见的http状态码" class="header-anchor">#</a> 5 常见的<code>HTTP</code>状态码</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>最常见：
<span class="token number">1</span>. <span class="token number">200</span> ok 表示从客户端发来的请求 在服务器端被正确处理
<span class="token number">2</span>. <span class="token number">404</span> not found 表示在服务器上没有找到请求的资源
<span class="token number">3</span>. <span class="token number">400</span> bad request 请求报文存在错误
<span class="token number">4</span>. <span class="token number">403</span> forbidden
<span class="token number">5</span>. <span class="token number">500</span> 服务器端在执行请求时发生了错误
<span class="token number">5</span>. <span class="token number">501</span> 服务器不支持当前请求的某个功能
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_6-dns协议是什么"><a href="#_6-dns协议是什么" class="header-anchor">#</a> 6 <code>DNS</code>协议是什么</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>DNS：域名系统 提供主机名到IP的转换服务
     是由分层的DNS服务器组成的分布式数据库 定义了主机如何查询这个分布式数据库的方式的应用层协议 使人更方便的访问互联网 而不用记住IP数组
作用：将域名解析为IP 客户端向DNS服务器发送域名查询请求 DNS告知客户端web服务器的IP地址
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_7-osi七层模型"><a href="#_7-osi七层模型" class="header-anchor">#</a> 7 <code>OSI</code>七层模型</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>ISO为了使网络应用更加普及 推出了OSI参考模型
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/1604024701811-7ac177bc-d649-45b8-8646-53af8f18a0de.webp" alt="img"></p> <h2 id="_8-tcp-ip网络模型"><a href="#_8-tcp-ip网络模型" class="header-anchor">#</a> 8 <code>TCP/IP</code>网络模型</h2> <h3 id="各有什么-负责什么"><a href="#各有什么-负责什么" class="header-anchor">#</a> 各有什么？负责什么？</h3> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 应用层: 负责与用户进行交互 我们直接接触到 包括应用软件都是在应用层实现 只需要专注于为用户提供应用功能 把数据传输给传输层 但并不关心数据是如何传输的 
          使用的是HTTP协议 传输的数据包就是消息或报文

<span class="token number">2</span>. 传输层: 应用层把数据传给传输层 为应用层提供网络支持 
          有 TCP UDP 传输协议
          TCP比UDP多了很多特性 比如 拥塞控制 超时重传 流量控制等
          但是UDP也有传输效率快 实时性更高的特点 不过它是只负责发送数据包 不保证一定能抵达对方
          在传输层收到应用层的数据如果很大的话 直接传输就不好控制，那么就规定如果数据包的大小超过了MSS即TCP最长报文长度的话 就分块。 好处是如果中途有丢失或者损坏 可以只发送那一个分块 这种分块称为TCP段

<span class="token number">3</span>. 网络层: 传输层负责把数据包拿过来 再判断是否切换 那么具体的传输操作它就让给了网络层 它自己就专心服务好应用层
           最常使用的就有IP协议  IP报文 <span class="token operator">=</span> IP头 + 传输层报文 
           如果IP报文超过了MTU 就会再次进行分片 得到一个即将发送到网络的IP报文

<span class="token number">4</span>. 网络接口层：最后一步准备 在IP头部的前面加上MAC头部 封装为数据帧 就可以发送到网络。
       这一步就涉及到以太网了嘛 以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。
       网络接口层为网络层提供链路级别传输的服务 负责在以太网 WIFI这样的底层网络上发送数据包 工作在网卡层次 使用MAC地址标识网络设备
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="端口"><a href="#端口" class="header-anchor">#</a> 端口</h3> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>   当设备作为接收方 从传输层给到应用层的时候 应用层是有很多应用软件的 那么我们把数据包给谁呢？ 
   需要拿编号来区别这些应用软件 这个就被称为端口
   比如80是web服务器的 <span class="token number">22</span>是远程登录服务器的 而浏览器每个标签栏都是一个独立进程 都会分配临时的端口号
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="ip地址"><a href="#ip地址" class="header-anchor">#</a> IP地址</h3> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>网络层负责将数据从一个设备传递给另一个设备 那么设备这么多 怎么找到对方捏？
所以 网络层需要有区别设备的编号 就是IP地址 IP地址 <span class="token operator">=</span> 网络号 + 主机号
这需要配合子网掩码才能算出 IP 地址 的网络号和主机号
网络号：IP地址 + 子网掩码 进行与运算
主机号：IP地址 + 子网掩码取反 进行与运算
匹配的话 需要匹配到相同的网络号（即同一个子网）才找对应的主机
路由寻址：找到这个子网 然后发送数据包进去
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="mac地址"><a href="#mac地址" class="header-anchor">#</a> MAC地址</h3> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>我们在网络层中判断网络包目的地用的是IP地址 但是在以太网中通讯要用到MAC地址
MAC头部是以太网使用的头部 它包含了接收方和发送方的MAC地址等信息 我们通过ARP协议获取到对方的MAC地址
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230407232613041.png" alt="image-20230407232613041" style="zoom:67%;"> <img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230407232632630.png" alt="image-20230407232632630" style="zoom:67%;"> <h2 id="_9-tcp-udp"><a href="#_9-tcp-udp" class="header-anchor">#</a> 9 <code>TCP/UDP</code></h2> <h3 id="概念和特点"><a href="#概念和特点" class="header-anchor">#</a> 概念和特点</h3> <p><strong>1. 都是传输层协议 都属于TCP/IP协议族</strong></p> <p><strong>2. 都是用来处理数据包</strong></p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>UDP：用户数据报协议；不提供数据包分组 组装和不能对数据进行排序 只负责发送数据包
     <span class="token number">1</span>. 无连接协议 不需要进行三次握手 只是数据包的搬运工『不会对报文进行拆分和拼接操作』
     
     <span class="token number">2</span>. 支持一对一 一对多 多对多的方式
     
     <span class="token number">3</span>. 面向报文 因为不拆分只添加一个UDP头部 应用层必须发送合适大小的报文
        发送端：应用层将数据传递给传输层的UDP协议 只会给数据增加一个UDP头 标识是UDP协议 然后就传输给网络层了
		接收端：网络层将数据传递给传输层 UDP只去除IP报文头就传递给应用层 不会拼接操作
     
     <span class="token number">4</span>. 不可靠 
        因为无连接 所以不可靠；
        收到什么就传递什么；不会备份；
        也不关心对方是否收到数据包；
        因为恒定速度发送数据 所以网络不好的时候 可能会导致丢包『没有拥塞控制 保持匀速』
     
        但是在某些实时性高的场景 就得使用UDP
     
     <span class="token number">5</span>. 头部开销小 传输数据报文高效『不需要像TCP一样需要保证数据不丢失且有序到达』
        只有8KB TCP的至少20字节
        
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>TCP：传输控制协议 面向连接 可靠的 基于字节流
     <span class="token number">1</span>. 面向连接 先进行三次握手 建立可靠连接
     <span class="token number">2</span>. 单播传输 一对一 每条TCP传输连接只能有两个端点 进行点对点传输
     <span class="token number">3</span>. 面向字节流 不会独立传输 而是不保留报文边界以字节流进行传输
     <span class="token number">4</span>. 可靠传输 根据TCP的段编号以及确认号来判断丢包 误码
     <span class="token number">5</span>. 拥塞控制 网络出现拥塞时 TCP能减少向网络注入数据的速率和数量
     <span class="token number">6</span>. 提供全双工通信 通信双方任何时候都能发送数据 因为TCP的连接都设有缓存 用来临时存放双向通信的数据
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>UDP头部 
  <span class="token number">1</span>. 两位十六位的端口号 分别是源端口『可选』和目标端口

TCP头部
  <span class="token number">1</span>. 几个重要的字段：
     Sequence number: 保证TCP传输的报文都是有序的 对端通过序号顺序拼接报文
     Acknowledgement number: 表示数据接收端 期望接收的下一个字节的编号是多少 同时也表示上一个序号的数据已经收到
     window Size: 窗口大小 表示还能接搜多少字节的数据 用于流量控制
  <span class="token number">2</span>. 标识符
     <span class="token assign-left variable">URG</span><span class="token operator">=</span><span class="token number">1</span> 包含紧急信息
     *ACK<span class="token operator">=</span><span class="token number">1</span> 确认号字段有效 连接建立后所有报文段都必须置ACK为1
     *SYN<span class="token operator">=</span><span class="token number">1</span> 与ACK<span class="token operator">=</span><span class="token number">0</span>搭配 表示当前是一个连接请求报文<span class="token punctuation">;</span> 与ACK<span class="token operator">=</span><span class="token number">1</span>是同意建立连接的应答报文
     *RST<span class="token operator">=</span><span class="token number">1</span> 表示连接出现问题 可能需要重新建立 也用于拒绝非法报文段和拒绝连接请求
     <span class="token assign-left variable">PSH</span><span class="token operator">=</span><span class="token number">1</span> 接收端要立即将数据push给应用层 而不是等缓冲区满后再提交
     *FIN<span class="token operator">=</span><span class="token number">1</span> 表示释放连接的请求报文
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h3> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 是否连接
<span class="token number">2</span>. 是否可靠
<span class="token number">3</span>. 连接对象个数
<span class="token number">4</span>. 传输方式* UDP面向报文 TCP面向字节流
<span class="token number">5</span>. 首部开销
<span class="token number">6</span>. 使用场景 UDP: 实时应用 例视频会议 直播 TCP: 可靠传输 文件传输
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h3> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>TCP 效率要求相对较低 但对准确性要求相对高 
    传输中需要对数据进行确认 重发 排序等
    比如 文件传输 远程登录 接受邮件
UDP 效率要求较高 对准确性要求相对低
    QQ聊天 在线视频 网络语音电话 即时通讯 广播通信
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_10-tcp三次握手和四次挥手"><a href="#_10-tcp三次握手和四次挥手" class="header-anchor">#</a> 10 TCP三次握手和四次挥手</h2> <h3 id="tcp头部格式"><a href="#tcp头部格式" class="header-anchor">#</a> TCP头部格式</h3> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 序列号『SYN』 建立连接时由计算机生成的随机数作为初始值 通过SYN传给接收端 每发送一次 就累加一次该数据字节流的大小 用来解决网络包乱序问题
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">2</span>. 确认应答号『ACK』 发送端收到 表明以前的数据都被正常接收 用来解决丢包的问题
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">3</span>. 控制位
   ACK: <span class="token number">1</span> <span class="token operator">==</span><span class="token operator">&gt;</span> 『确认应答』字段有效 最初建立连接的SYN可以不为1
   RST: <span class="token number">1</span> <span class="token operator">==</span><span class="token operator">&gt;</span> TCP连接出现异常 必须强制断开连接
   SYN: <span class="token number">1</span> <span class="token operator">==</span><span class="token operator">&gt;</span> 希望建立连接 并设定『序列号』初始值
   FIN: <span class="token number">1</span> <span class="token operator">==</span><span class="token operator">&gt;</span> 不会再有数据发送 希望断开连接
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="三次握手"><a href="#三次握手" class="header-anchor">#</a> 三次握手</h3> <p><strong>IP层是不可靠的 并不保证网络包的交付 不保证按序交付和完整性 要想保证可靠 由上层的TCP协议负责</strong></p> <p><strong>建立一个TCP连接时 需要客户端和服务端总共发送3个包</strong></p> <p><strong>为了确认双方的接收能力和发送能力是否正常 指定初始化序列号为后面的可靠性传送做准备</strong></p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 客户端<span class="token operator">==</span><span class="token operator">&gt;</span>服务端 发送一个SYN报文（不能携带数据） 并指明初始化序列号（client_isn）
   同步位 <span class="token assign-left variable">SYN</span><span class="token operator">=</span><span class="token number">1</span> 初始序列号 <span class="token assign-left variable">seq</span><span class="token operator">=</span>client_isn
   
<span class="token number">2</span>. 服务端<span class="token operator">==</span><span class="token operator">&gt;</span>客户端 应答自己的SYN报文 指定初始化序列号（server_isn） 指定ACK为初始序列+1
   同步位 <span class="token assign-left variable">SYN</span><span class="token operator">=</span><span class="token number">1</span> 初始序列号 <span class="token assign-left variable">seq</span><span class="token operator">=</span>server_isn 确认序列号 <span class="token assign-left variable">ack</span><span class="token operator">=</span>client_isn+1
   
   客户端收到之后 确认了第一次握手中自己的发送能力和服务端的接收能力
   
<span class="token number">3</span>. 客户端<span class="token operator">==</span><span class="token operator">&gt;</span>服务端 发送一个ACK报文 （可以携带数据）
   同步位 <span class="token assign-left variable">ACK</span><span class="token operator">=</span><span class="token number">1</span> 确认号 <span class="token assign-left variable">ack</span><span class="token operator">=</span>server_isn+1 初始序列号seq<span class="token operator">=</span>client_isn+1『因为是第二个报文段』 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230408135336996.png" alt="image-20230408135336996" style="zoom:80%;"> <h3 id="为什么是三次握手"><a href="#为什么是三次握手" class="header-anchor">#</a> 为什么是三次握手？</h3> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>之前学习的时候 确实觉得只有三次握手才能保证双方具有接收和发送的能力 
    在客户端第一次接收到服务器端的消息时 可以确保客户端的发送能力和服务端的接收能力 
    服务端第二次收到消息的时候 可以确保自己的发送能力和客户端的接收能力
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>后来看博客的时候 还学习到一个比较重要的点：也就是三次握手的首要原因
   三次握手可以阻止重复历史连接的初始化 防止旧的重复连接初始化造成混乱
   比如客户端连续发送多次SYN建立连接的报文 在网络拥堵的情况下：
   一个旧的报文『seq<span class="token operator">=</span><span class="token number">90</span>』比最新的SYN报文『seq<span class="token operator">=</span><span class="token number">100</span>』早到达了服务端 那么服务端回一个ACk报文『确认号91』
   但是客户端希望收到的是『确认号为101』的ACK报文 于是回RST报文
   服务端收到RST报文后 就会释放连接
   后续最新的SYN到达了服务端 就可以正常完成三次握手了
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>『 旧<code>SYN</code>报文 』称为历史连接 。<code>TCP</code>三次握手建立连接的最主要原因就是防止『 历史连接 』初始化了连接。</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>如果是两次握手 就无法阻止了：服务端没有中间状态给客户端来阻止历史连接 导致服务端可能建立一个历史连接 造成资源浪费
二次握手：服务端收到SYN报文后 就进入ESTABLISTEN状态 可以发送数据了 
         但是客户端判断到此处为历史连接就发RST报文断开连接 
         如果服务端在向客户端发送数据前 没有阻止掉历史连接 导致服务端建立了历史连接 又白白发送了数据 浪费了服务端的资源
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>原因2：同步双方初始序列号

原因3：避免资源浪费 由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文，所以服务端每收到一个 SYN 就只能先主动建立一个连接
      如果客户端发送的 SYN 报文在网络中阻塞了，重复发送多次 SYN 报文，那么服务端在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="四次挥手"><a href="#四次挥手" class="header-anchor">#</a> 四次挥手</h3> <p><strong>TCP断开连接是通过四次挥手方式</strong></p> <p><strong>双方都可以主动断开连接 断开连接后主机的资源将被释放</strong></p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>客户端主动关闭连接 —— tcp四次挥手
<span class="token number">1</span>. 客户端<span class="token operator">==</span><span class="token operator">&gt;</span>服务端 发送断开连接的FIN报文 不再发送数据 但还可以接收数据
<span class="token number">2</span>. 服务端<span class="token operator">==</span><span class="token operator">&gt;</span>客户端 收到后发送ACK应答报文 可能还有数据需要处理和发送
<span class="token number">3</span>. 服务端<span class="token operator">==</span><span class="token operator">&gt;</span>客户端 服务端处理完数据之后不再发送了 才发送FIN报文 表示同意现在关闭连接
<span class="token number">4</span>. 客户端<span class="token operator">==</span><span class="token operator">&gt;</span>服务端 收到后发送ACK应答报文
可以看到每个方向都需要一个FIN和一个ACK 因此为四次挥手 服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，因此是需要四次挥手。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230408155359254.png" alt="image-20230408155359254"></p> <h2 id="_11-keep-alive的理解"><a href="#_11-keep-alive的理解" class="header-anchor">#</a> 11 <code>keep-alive</code>的理解</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>概念：是使客户端和服务器端的连接持续有效 当出现对服务器的后续请求时 keep-alive避免建立或重新建立连接 就是长连接

http1.0 默认是短连接 每次请求和应答 要建立连接 完成后马上断开 需要发送collection字段
http1.1 默认保持长连接
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>建立过程：
<span class="token number">1</span>. 客户端<span class="token operator">==</span><span class="token operator">&gt;</span>服务端 发送请求报文同时添加Connection字段
<span class="token number">2</span>. 服务端<span class="token operator">==</span><span class="token operator">&gt;</span>客户端 收到并处理字段 回送Connection:Keep-alive
<span class="token number">3</span>. 客户端收到Connectionz字段 连接建立成功
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>优点：
<span class="token number">1</span>. 较少CPU和内存使用『同时打开的连接减少了』
<span class="token number">2</span>. 减少了后续请求的延迟『不需要每次都建立连接』
<span class="token number">3</span>. 减低拥塞控制『TCP的连接减少了』
缺点：
长时间的TCP连接容易导致系统资源无效占用 浪费系统资源
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h1 id="_2023年4月10日-星期一"><a href="#_2023年4月10日-星期一" class="header-anchor">#</a> 2023年4月10日 星期一</h1> <h2 id="_1-vue的基本原理"><a href="#_1-vue的基本原理" class="header-anchor">#</a> 1 Vue的基本原理</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>vue最深刻的两个特点 肯定就是响应式编程（双向数据绑定） 组件化嘛
优势是：轻量 双向数据绑定 组件化 数据和结构分离 虚拟DOM 运行速度快
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>当一个Vue实例创建时 Vue会遍历到data中的属性 用Object.defineProperty将它们转换为getter/setter 并且在内部追踪相关依赖 在属性被访问和修改时通知变化，每个组件实例都有相应的Watcher程序实例 它会在组件渲染的过程中把属性记录为依赖 之后当依赖项的setter被调用时 会通知Watcher重新计算 从而使关联的组件得以更新。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>vue是一个MVVM渐进式框架 MVVM是Vue设计模式 在Vue框架中数据会自动驱动视图
<span class="token number">1</span>. MVVM设计模式
   Model：数据模型 就是Vue组件中的data或者Vuex中的数据
   View：视图 就是DOM 对应html部分即UI组件 负责将数据模型展示出来
   ViewModel：监听模型数据即data 改变或控制视图行为 处理用户交互等
   Model和View没有直接联系 而是通过ViewModel进行交互 之间交互是双向的。ViewModel通过双向数据绑定将View和Model连接起来 之间的同步工作不需要开发者干涉 不需要手动操作DOM 只需要关注业务逻辑即可
   
<span class="token number">2</span>. 响应式：View和Model之间的同步工作
   Vue在创建实例的时候 遍历data中的属性 通过ES5的Object.defineProperty 将它们转化为getter/setter 在属性上添加访问器属性 当读取到data中的数据会自动调用get方法 修改时会自动调用set方法 检测到数据的变化 会通知观察者Watcher 然后自动触发重新render组件 生成新的虚拟DOM对象 对比后局部修改到真实DOM树上
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><a href="https://juejin.cn/post/6844903902429577229" target="_blank" rel="noopener noreferrer">面试官: 你对虚拟DOM原理的理解? - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="_2-computed-和-watch-的区别"><a href="#_2-computed-和-watch-的区别" class="header-anchor">#</a> 2. <code>Computed</code> 和 <code>Watch</code> 的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>Computed: 
   <span class="token number">1</span>. 支持缓存 只有依赖的数据发生了变化 才会重新计算
   <span class="token number">2</span>. 不支持异步 当computed有异步操作时 无法监听数据的变化
   <span class="token number">3</span>. 基于响应式依赖进行缓存，即data或者props
   <span class="token number">4</span>. 如果属性是函数则默认使用get方法 可以有set和get方法
Watch:
   <span class="token number">1</span>. 不支持缓存 数据变化时 就触发相应的操作
   <span class="token number">2</span>. 支持异步监听
   <span class="token number">3</span>. 函数支持两个参数 一个是新值 一个是旧值
   <span class="token number">4</span>. 监听的数据必须是data中声明的或者props数据，函数有两个参数：
      immediate: 组件加载时立即触发回调函数
      deep:深度监听 可以监听到数组中的对象发生变化 但是无法监听到数组和对象内部的变化
   当想要执行异步或者昂贵的操作以响应不断的变化 就使用Watch
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>Computed有缓存 根据依赖的属性值发生改变 才会重新计算 如果没变 就直接从缓存拿数据了
Watch没有缓存 是监听 类似数据的监听回调 每当监听的数据发生变化就会执行回调进行后续的操作
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_3-v-if和v-show的区别"><a href="#_3-v-if和v-show的区别" class="header-anchor">#</a> 3. <code>v-if</code>和<code>v-show</code>的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. v-if是动态添加或删除DOM元素 v-show是设置DOM元素的display样式
<span class="token number">2</span>. v-if切换有局部编译和卸载的过程 v-show只是单纯地基于css
<span class="token number">3</span>. v-if惰性编译 只有第一次为真才开始编译 v-show是无论什么都会编译 缓存 保留DOM元素
<span class="token number">4</span>. v-if有更高的切换消耗 v-show有更高的初始渲染消耗
<span class="token number">5</span>. v-id适合条件不怎么改变的 v-show适合频繁切换
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_4-data为什么是函数而不是对象"><a href="#_4-data为什么是函数而不是对象" class="header-anchor">#</a> 4. <code>data</code>为什么是函数而不是对象</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>Vue组件可能会存在多个实例 如果采用对象形式定义data 则会导致公用一个data对象 那么状态变更将会影响所有组件实例 
但是使用函数形式定义 在initData时则会作为工厂函数返回全新data对象 有效规避多实例之间状态污染问题
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_5-vue-单⻚应用与多⻚应用的区别"><a href="#_5-vue-单⻚应用与多⻚应用的区别" class="header-anchor">#</a> 5 Vue 单⻚应⽤与多⻚应⽤的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>SPA单页面应用指的是只有一个主页面的应用 一开始只需要加载一次js css资源 相关的内容都包含在主页面里面 对每个功能模块化组件化 单页应用跳转 就是切换相关组件 刷新局部资源
MPA多页面应用指的是有多个独立页面的应用 每个页面必须重复加载js css资源 多页应用跳转 需要整页资源刷新
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_5-vue的优点"><a href="#_5-vue的优点" class="header-anchor">#</a> 5. Vue的优点</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 轻量级框架：只关注视图层
<span class="token number">2</span>. 双向数据绑定
<span class="token number">3</span>. 组件化
<span class="token number">4</span>. 数据 视图 结构分离
<span class="token number">5</span>. 虚拟DOM：dom操作时非常耗费性能的
<span class="token number">6</span>. 运行速度更快 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_6-对-spa-单⻚面的理解-它的优缺点分别是什么"><a href="#_6-对-spa-单⻚面的理解-它的优缺点分别是什么" class="header-anchor">#</a> 6. 对 SPA 单⻚⾯的理解，它的优缺点分别是什么？</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>SPA: 仅在web页面初始化的时候加载相应的js css html。一旦页面加载完成 SPA就因为用户的操作而进行页面的重新加载或跳转；而是利用html内容的变化 UI与用户的交互 避免页面的重新加载。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>优点：
   <span class="token number">1</span>. 用户体验好 避免不必要的跳转和重复渲染，不需要重新加载整个页面
   <span class="token number">2</span>. SPA就相对服务器压力小
   <span class="token number">3</span>. 前后端分离 前端进行交互逻辑 后端负责数据处理

缺点：
   <span class="token number">1</span>. 初次加载耗时多 为了实现单页面应用和显示效果 需要在加载页面的时候将JavaScript css统一加载 部分页面要按需加载
   <span class="token number">2</span>. 前进后退路由管理，浏览器不会自动记录 所有的页面切换需要自己建立堆栈管理vue-router
   <span class="token number">3</span>. SEO难度较大
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_7-说一下生命周期"><a href="#_7-说一下生命周期" class="header-anchor">#</a> 7. 说一下生命周期</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>从开始创建 初始化数据 编译模板 挂载DOM <span class="token operator">==</span><span class="token operator">&gt;</span> 渲染 更新 <span class="token operator">==</span><span class="token operator">&gt;</span> 渲染 卸载等一系列过程 称为Vue的生命周期
流程线：beforeCreate『创建前』 <span class="token operator">==</span><span class="token operator">&gt;</span> created『创建后』 <span class="token operator">==</span><span class="token operator">&gt;</span> beforeMount『挂载前』 <span class="token operator">==</span><span class="token operator">&gt;</span> mounted『挂载后』 <span class="token operator">==</span><span class="token operator">&gt;</span> 
       beforeUpdate『更新前』 <span class="token operator">==</span><span class="token operator">&gt;</span> updated『更新后』 <span class="token operator">==</span><span class="token operator">&gt;</span> beforeDestory『销毁前』 <span class="token operator">==</span><span class="token operator">&gt;</span> destoryed『销毁后』
生命周期函数中的this指向是vm或组件实例对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. beforeCreate: 初始化事件和数据监测还没开始 什么都访问不到。已经初始化了 但是还没有数据监测和数据代理
   created: 实例创建完成 实际上配置的data computed <span class="token function">watch</span> methods等都已经完成 但是此刻渲染的节点还未挂载到DOM上 还不能访问到<span class="token variable">$el</span>，已经完成数据监测和数据代理

<span class="token number">2</span>. beforeMount: 在挂载前渲染 编译模板 生成html 此刻还没有被挂载html到页面上。 已经编译模板 生成了虚拟DOM
   mounted: vue完成模板的解析并把初始的真实DOM放入到页面后就调用mounted。页面上已经是经过编译后的DOM页面 可以进行DOM的操作。在这个阶段可以进行开启定时器啊 发送网络请求 绑定自定义事件 订阅事件之类
   
<span class="token number">3</span>. beforeUpdate: 此时是新数据 但旧页面
   updated: 数据与页面同步
   
<span class="token number">4</span>. beforeDestoryed: 此时的DOM还是可用的还可以访问到 进入准备销毁阶段 可以开始关闭定时器 取消订阅之类 解绑自定义事件的操作 一般在这个阶段不会操作数据了 即便操作也不会触发更新流程了
   destoryed: 销毁Vue实例
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_8-组件通信的方式"><a href="#_8-组件通信的方式" class="header-anchor">#</a> 8.  组件通信的方式</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. props <span class="token variable">$emit</span>
   父组件向子组件传值 通过props
   子组件向父组件传值 通过<span class="token variable">$emit</span> 绑定一个自定义事件 当这个事件被执行的时候就会将参数传递给父组件 而父组件通过v-on监听并接收参数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 子组件中声明的函数</span>
<span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'onEmitIndex'</span><span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 触发父组件的方法 传递参数index</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-vue line-numbers-mode"><pre class="language-vue"><code>// 父组件中对子组件的引用
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">@onEmitIndex</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>handleEmit<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span><span class="token punctuation">/&gt;</span></span>
    
handleEmit(index){
    this.index = index;  // 这个index就是子组件传过来的
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">2</span>. eventBus事件总线 <span class="token variable">$emit</span> <span class="token variable">$on</span>
   创建事件中心管理组件之间的通信 <span class="token builtin class-name">export</span> const EventBus <span class="token operator">=</span> new Vue<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>然后在组件中进行引入.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 组件：发送事件</span>
EventBus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'addition'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
   <span class="token literal-property property">num</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token operator">++</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>// 接收事件
EventBus.<span class="token variable">$on</span><span class="token punctuation">(</span><span class="token string">'addition'</span>, param <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
	console.log<span class="token punctuation">(</span>param<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">3</span>. vue依赖注入 用于层数比较深的父子或祖孙这类的组件来传值 就不需要一层一层进行传递
   provide/inject 是vue提供的钩子和data是同级的
   provide: 钩子用来发送数据或方法
   inject: 用来接收数据和方法
   但是依赖注入所提供的属性是非响应式的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 父组件 provide和data书写形式一致</span>
<span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    retutn<span class="token punctuation">{</span>
        <span class="token literal-property property">num</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">;</span>  <span class="token comment">// 只传递num</span>
        <span class="token literal-property property">app</span><span class="token operator">:</span> <span class="token keyword">this</span>       <span class="token comment">// 这样就可以访问父组件的所有属性了</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 子组件</span>
<span class="token literal-property property">inject</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'num'</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">4</span>. ref或<span class="token variable">$refs</span> 用于实现父子组件之间的通信
   ref用于子组件上 引用指向了子组件的实例 可以通过实例来访问
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 在父组件中声明子组件</span>
<span class="token operator">&lt;</span>Child ref<span class="token operator">=</span><span class="token string">&quot;child&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    
<span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>child<span class="token punctuation">)</span>  <span class="token comment">// 这样就可以访问到child组件的所有方法和属性了  </span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">5</span>. <span class="token variable">$parent</span>/<span class="token variable">$children</span> 
   使用<span class="token variable">$parent</span> 可以让组件访问父组件的实例 访问的是上一级父组件
   使用<span class="token variable">$children</span> 可以让组件访问子组件的实力 但不能保证顺序 拿到的是所有子组件的实例 是一个数组并无序
   可以通过<span class="token variable">$root</span>访问到根组件的实例
   <span class="token variable">$children</span> 的值是数组，⽽ <span class="token variable">$parent</span> 是个对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">6</span>. <span class="token variable">$attrs</span>/<span class="token variable">$listeners</span><span class="token builtin class-name">:</span> 实现组件之间的跨代通信 直系祖孙传递数据
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_9-路由的hash和history模式的区别"><a href="#_9-路由的hash和history模式的区别" class="header-anchor">#</a> 9.  路由的<code>hash</code>和<code>history</code>模式的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>vue-router默认模式就是hash模式
<span class="token number">1</span>. hash模式的URL带着一个 <span class="token comment"># </span>
   只会出现在URL里面 但不会出现在HTTP请求中 对后端没有影响
   兼容性很好 低版本IE也支持 hash路由被称为前端路由
   原理：onhashchange<span class="token punctuation">(</span><span class="token punctuation">)</span>事件：在页面的hash值发生变化 无需向后端发起请求 window可以监听事件改变 按规则加载相应的代码 另外hash值对应的URL都会被浏览器记录下来 实现页面的前进和后退
   
<span class="token number">2</span>. history模式没有 <span class="token comment"># 使用的是传统的路由分发模式 用户输入一个URL 服务器会接收这个请求 并解析URL 做出相应的逻辑处理</span>
   相对hash模式更加好看 但需要后台配置 不然会返回404
   有两部分history API：切换后台状态和修改历史状态
   pushState<span class="token punctuation">(</span><span class="token punctuation">)</span> replaceState<span class="token punctuation">(</span><span class="token punctuation">)</span> forward<span class="token punctuation">(</span><span class="token punctuation">)</span> back<span class="token punctuation">(</span><span class="token punctuation">)</span> go<span class="token punctuation">(</span><span class="token punctuation">)</span>
   缺点：在刷新的时候 没有相应的路由或资源 会刷出404
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_10-定义动态路由和获取路由参数"><a href="#_10-定义动态路由和获取路由参数" class="header-anchor">#</a> 10 定义动态路由和获取路由参数</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. param方式：需要提前在声明时进行占位
   格式：/router/:id/:title  到时使用的时候直接进行传值即可
   注意：如果是对象写法 只能和name搭配使用
   参数获取的时候: <span class="token variable">$route</span>.params.id <span class="token variable">$route</span>.params.title
   
<span class="token number">2</span>. query方式：在路径参数会出现?号
   声明的时候就是普通配置 不需要其他
   格式：使用query的key作为传递  形成的路径信息：/router?id<span class="token operator">=</span><span class="token number">123</span> 可以和name或者path搭配的ok
   参数获取：<span class="token variable">$route</span>.query 获取传递的值
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="language-html line-numbers-mode"><pre class="language-html"><code>// 示例 params
// 1. 直接在router-link中使用
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">'</span>/router/'+id+'/'+title<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 2. 使用跳转方法进行</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'user'</span><span class="token punctuation">,</span> <span class="token literal-property property">params</span><span class="token operator">:</span><span class="token punctuation">{</span>id<span class="token punctuation">,</span> title<span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'router'</span><span class="token operator">+</span>id<span class="token operator">+</span><span class="token string">'/'</span><span class="token operator">+</span>title<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-html line-numbers-mode"><pre class="language-html"><code>// 实例 query 
// 1. path+query搭配
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{
       path: '/router',
       query: {id:123, title:'hello'}
}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>
// 2. name+query搭配
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{
       name: 'Category',
       query: {id:123, title:'hello'}
}<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 使用跳转方法</span>
<span class="token comment">// 3. name/path+query</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'user'</span><span class="token punctuation">,</span> <span class="token literal-property property">query</span><span class="token operator">:</span><span class="token punctuation">{</span>id<span class="token punctuation">,</span> title<span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">path</span><span class="token operator">:</span><span class="token string">'/user'</span><span class="token punctuation">,</span> <span class="token literal-property property">query</span><span class="token operator">:</span><span class="token punctuation">{</span>id<span class="token punctuation">,</span> title<span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 4. 路径形式</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'/router?id='</span><span class="token operator">+</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>params和query的区别：
<span class="token number">1</span>. query可以用path或者name来引入 但params只能使用name来引入
<span class="token number">2</span>. 接收参数的方式都是类似的 this.<span class="token variable">$route</span>.query.id this.<span class="token variable">$route</span>.params.id
<span class="token number">3</span>. query携带?号 类似get传参 params类似post
   query会在浏览器中显示url参数 后者则不显示
<span class="token number">4</span>. query刷新不会丢失query里面的数据 params会丢失
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_11-对前端路由的理解"><a href="#_11-对前端路由的理解" class="header-anchor">#</a> 11. 对前端路由的理解</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 前端早期 一个URL对应一个页面 页面的切换必然伴随页面的刷新 也是因为只有页面刷新才可以重新去请求数据
<span class="token number">2</span>. 后来出现Ajax 可以在不刷新页面的情况下进行数据请求 更新页面内容 之后就出现了SPA单页面应用
<span class="token number">3</span>. SPA极大提升了用户体验 允许在不刷新的情况下更新页面内容 使内容的切换更加流畅。但一开始时并没有定位这一说 内容切换前后的URL是一致的 也不会保留你当前的进展 一刷新就回到最初的起点 且只有一个URL给页面做映射 对SEO也不够友好
<span class="token number">4</span>. 为解决 前端路由出现 帮助我们在仅有一个页面的情况下 记住用户当前的操作 为每一个视图都匹配唯一标识来判断当前的位置 为了刷新之后内容也不归零
<span class="token number">5</span>. 思路是这样的：
   <span class="token number">1</span>. 拦截用户的刷新操作 
   <span class="token number">2</span>. 感知URL的变化 在前端对URL做一个微小的处理 不影响本身的性质和服务器对它的识别 一旦感知到了这个变化 就用js来生成不同的内容
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h1 id="_2023年4月17日-星期一"><a href="#_2023年4月17日-星期一" class="header-anchor">#</a> 2023年4月17日 星期一</h1> <h2 id="_1-promise的理解"><a href="#_1-promise的理解" class="header-anchor">#</a> 1. <code>Promise</code>的理解</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. Promise 对象是异步编程的⼀种解决⽅案，最早由社区提出。

<span class="token number">2</span>. Promise 是⼀个构造函数，接收⼀个函数作为参数，返回⼀个 Promise 实例。⼀个 Promise 实例有三种状态，分别是pending、resolved 和rejected，分别代表了进⾏中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态⼀经改变，就凝固了，⽆法再被改变了。

<span class="token number">3</span>. 状态的改变是通过 resolve<span class="token punctuation">(</span><span class="token punctuation">)</span> 和 reject<span class="token punctuation">(</span><span class="token punctuation">)</span> 函数来实现的，可以在异步操作结束后调⽤这两个函数改变Promise 实例的状态，它的原型上定义了⼀个 <span class="token keyword">then</span> ⽅法，使⽤这个 <span class="token keyword">then</span> ⽅法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执⾏。

注意：在构造 Promise 的时候，构造函数内部的代码是⽴即执⾏的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// some code</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 返回的promise对象 还可以调用then方法</span>
<span class="token comment">// then ⽅法可以接受两个回调函数作为参数。第⼀个回调函数是Promise对象的状态变为 resolved 时调⽤，第⼆个回调函数是Promise对象的状态变为 rejected 时调⽤。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_2-对async-await的理解"><a href="#_2-对async-await的理解" class="header-anchor">#</a> 2. 对<code>async/await</code>的理解</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. async/await是Generator的语法糖 它实现的效果都能通过then来实现 是为了优化then链开发出来的

<span class="token number">2</span>. 从字⾯上来看，async是“异步”的简写，await则为等待，所以很好理解async ⽤于申明⼀个 <span class="token keyword">function</span> 是异步的，⽽ await ⽤于等待⼀个异步⽅法执⾏完成。当然语法上强制规定await只能出现在asnyc函数中。

<span class="token number">3</span>. async 函数返回的是⼀个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回⼀个 Promise 对象，如果在函数中 <span class="token builtin class-name">return</span> ⼀个直接量，async 会把这个直接量通过 Promise.resolve<span class="token punctuation">(</span><span class="token punctuation">)</span> 封装成 Promise 对象。async 函数返回的是⼀个 Promise 对象，所以在最外层不能⽤ await 获取其返回值的情况下，当然应该⽤原来的⽅式： then<span class="token punctuation">(</span><span class="token punctuation">)</span> 链来处理这个 Promise 对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>await在等待什么？

<span class="token number">1</span>. await 表达式的运算结果取决于它等的是什么。
   如果它等到的不是⼀个 Promise 对象，那 await 表达式的运算结果就是它等到的东⻄。
   如果它等到的是⼀个 Promise 对象，await 就忙起来了，它会阻塞后⾯的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。
   
<span class="token number">2</span>. 单⼀的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的then 链的时候，优势就能体现出来了（很有意思，Promise 通过 <span class="token keyword">then</span> 链来解决多层回调的问题，现在⼜⽤ async/await 来进⼀步优化它）。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div> <img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230418001134652.png" alt="image-20230418001134652" style="zoom:80%;"> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>async/await对⽐Promise的优势

<span class="token number">1</span>. 代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担
<span class="token number">2</span>. Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅
<span class="token number">3</span>. 错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余
<span class="token number">4</span>. 调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进<span class="token punctuation">(</span>step-over<span class="token punctuation">)</span>功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h1 id="_2023年4月18日-星期二"><a href="#_2023年4月18日-星期二" class="header-anchor">#</a> 2023年4月18日 星期二</h1> <h2 id="_1-事件代理"><a href="#_1-事件代理" class="header-anchor">#</a> 1. 事件代理</h2> <p><strong>DOM事件三大阶段：捕获-目标-冒泡</strong>。</p> <h3 id="_1-1-事件委托"><a href="#_1-1-事件委托" class="header-anchor">#</a> 1.1 事件委托</h3> <p>利用 <a href="http://c.biancheng.net/view/9379.html" target="_blank" rel="noopener noreferrer">JS 事件冒泡<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>动态为元素绑定事件的方法称为<strong>事件委托</strong>（Event Delegation，也称为“事件代理”），是 JavaScript 中最热门的技术之一。</p> <p>要使用事件委托，需要保证事件能够发生冒泡，适合使用事件委托的事件有  <code>click</code>、<code>mousedown</code>、<code>mouseup</code>、<code>keydown</code>、<code>keyup</code>、keypress 等。</p> <p>需要注意的是，虽然 <code>mouseover</code>和  <code>mouseout</code>事件也会发生事件冒泡，但处理起来非常麻烦，所以<strong>不推荐</strong>在 <code>mouseover</code>和 <code>mouseout</code>事件中使用事件委托。</p> <p>另外，对于不会发生事件冒泡的事件（例如 load、unload、abort、focus、blur 等），则无法使用事件委托。</p> <h3 id="_1-2-事件冒泡"><a href="#_1-2-事件冒泡" class="header-anchor">#</a> 1.2 事件冒泡</h3> <p><img src="http://c.biancheng.net/uploads/allimg/210927/09441W5b-0.gif" alt=""></p> <ol><li>在事件捕获阶段，事件会从 DOM 树的最外层开始，依次经过目标节点的各个父节点，并触发父节点上的事件，直至到达事件的目标节点。</li> <li>事件冒泡正好与事件捕获相反，事件冒泡是从目标节点开始，沿父节点依次向上，并触发父节点上的事件，直至文档根节点。</li></ol> <h4 id="_1-2-1-阻止事件捕获和冒泡"><a href="#_1-2-1-阻止事件捕获和冒泡" class="header-anchor">#</a> 1.2.1 阻止事件捕获和冒泡</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>event<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 会阻止事件捕获和事件冒泡，但是无法阻止标签的默认行为，如链接。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻止一些默认行为。如链接和提交按钮。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_2-事件循环"><a href="#_2-事件循环" class="header-anchor">#</a> 2. 事件循环</h2> <h3 id="_2-1-大前提"><a href="#_2-1-大前提" class="header-anchor">#</a> 2.1 大前提：</h3> <p>首先，<code>JavaScript</code>是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，<strong>而实现单线程非阻塞的方法就是事件循环</strong>。</p> <h3 id="_2-2-分类"><a href="#_2-2-分类" class="header-anchor">#</a> 2.2 分类</h3> <p>在<code>JavaScript</code>中，所有的任务都可以分为</p> <ul><li>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</li> <li>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等。</li></ul> <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/21/15fdd88994142347~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" style="zoom:50%;"> <p>导图要表达的内容用文字来表述的话：</p> <ul><li>同步和异步任务分别进入不同的执行&quot;场所&quot;，同步的进入主线程，异步的进入Event Table并注册函数。</li> <li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li> <li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li> <li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul> <p><a href="https://juejin.cn/post/6844903512845860872" target="_blank" rel="noopener noreferrer">事件循环参考掘金博客<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/15fdcea13361a1ec~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img" style="zoom:50%;"> <ul><li><strong><code>javascript</code>是一门单线程语言</strong></li> <li><strong>Event Loop是<code>javascript</code>的执行机制</strong></li></ul> <h2 id="_3-垃圾回收机制"><a href="#_3-垃圾回收机制" class="header-anchor">#</a> 3. 垃圾回收机制</h2> <h3 id="_3-1-前提"><a href="#_3-1-前提" class="header-anchor">#</a> 3.1 前提</h3> <p>因为<strong>内存泄漏</strong>了，所以引擎才会去回收这些没有用的变量，这一过程就叫垃圾回收。</p> <p>程序的运行需要占用内存，**当这些程序没有用到时，还不释放内存，就会引起内存泄漏。**不再用到的内存，没有及时释放，就被称为内存泄漏。内存泄漏，会让系统占用极高的内存，让系统变卡甚至奔溃。</p> <p>导致这问题的原因是 JavaScript 的引擎 V8 只能使用一部分内存，具体来说，在 64 位系统下，V8 最多只能分配 1.4G；在 32 位系统中，最多只能分配 0.7G。</p> <p>因为使用内存大小上限，所以当有用不到的变量时，引擎会帮我们清理掉。</p> <h3 id="_3-2-回收"><a href="#_3-2-回收" class="header-anchor">#</a> 3.2 回收</h3> <p><strong>回收内存。清理变量，释放内存空间</strong></p> <p>参考链接：<a href="https://zhuanlan.zhihu.com/p/576722965" target="_blank" rel="noopener noreferrer">深入理解垃圾回收机制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_3-3-机制"><a href="#_3-3-机制" class="header-anchor">#</a> 3.3 机制</h3> <p>基本类型存在栈内存，引用类型存在堆内存。</p> <p><strong>引擎需要栈来维护程序执行时的上下文状态</strong>，如果所有数据都存放在栈内存中，会影响到上下文切换的效率，从而影响整个程序的执行效率。所以内容大的被存放到堆内存中。</p> <img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230317164756336.png" alt="image-20230317164756336" style="zoom:80%;"> <img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/v2-ba1ae480cc0a1382e0b607ba92cabe75_r.jpg" style="zoom:67%;"> <p><img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/v2-33f352d7ded14073b6fbf83a8b90dad5_r.jpg" alt="img"></p> <ul><li><p>Scavenge 算法：将空间分为两半，一半是 from 空间，一半是 to 空间。新加入的对象会放在 from 空间，当空间快满时，执行垃圾清理；再角色调换，再当调换完后的 from 空间快蛮时，再执行垃圾清理，如此反复</p></li> <li><p>标记-清理-整理：此为两个算法，「标记-清理」算法和 「标记-整理」算法</p></li> <li><ul><li>标记-清理：标记用不到的变量，清理掉</li> <li>标记-整理：清理完内存后，会产生不连续的内存空间，为节省空间，整理算法会将内存排序到一处空间，空间就变大了</li></ul></li></ul> <h3 id="_3-4-引用计数"><a href="#_3-4-引用计数" class="header-anchor">#</a> 3.4 引用计数</h3> <p>引擎会有张”引用表“，保存了内存里面的资源的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。将<code>arr</code>置为<code>null</code>即可</p> <p>出现问题：数组<code>[1,2,3,4]</code>是一个值，会占用内存。但被<code>arr</code>引用了。因此引用次数为1，但接下来的代码却没有用到<code>arr</code>，因此还是会持续占用内存。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>只要外部的引用消失，<code>WeakMap</code>内部的引用，就会自动被垃圾回收清除。</p> <h3 id="_3-5-哪些操作"><a href="#_3-5-哪些操作" class="header-anchor">#</a> 3.5 哪些操作</h3> <h4 id="几种造成内存泄漏的情况"><a href="#几种造成内存泄漏的情况" class="header-anchor">#</a> <strong>几种造成内存泄漏的情况：</strong></h4> <ol><li><p>意外声明全局变量。不使用<code>var</code>声明的变量，相当于挂载到<code>window</code>上。这样子只要window对象没有被清理，那么它的属性就一直存在，造成内存泄漏。</p> <p>**解决方法：**加上声明关键字；使用<code>this</code>关键字；严格模式；赋值为<code>null</code></p></li> <li><p>定时器导致的泄露。<code>setInterval(()=&gt;{},100)</code></p></li> <li><p>闭包：只要返回的函数存在就不能清理 <code>name</code></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> fn <span class="token operator">=</span> <span class="token function">functuon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">&quot;mary&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>没有清理的<code>DOM</code>元素引用</p></li></ol> <h4 id="减少垃圾回收"><a href="#减少垃圾回收" class="header-anchor">#</a> <strong>减少垃圾回收</strong></h4> <p>**前提：**尽管浏览器可以进行垃圾自动回收 但是当代码比较复杂的时候 垃圾回收带来的 代价比较大 所以应该减少垃圾回收</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 对数组进行优化：最简单的就是赋值为<span class="token punctuation">[</span><span class="token punctuation">]</span> 但这种情况会创建一个新对象出来 最好将数组的长度设置为0 以此达到清空数组的目的
<span class="token number">2</span>. 对object进行优化：对象尽量复用 设置为null
<span class="token number">3</span>，对函数进行优化：如果可以复用在函数中的的函数表达式，尽量放在函数外面
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_4-vuex的原理"><a href="#_4-vuex的原理" class="header-anchor">#</a> 4. Vuex的原理</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>vuex是专门为vue.js开发的状态管理模式 每个vuex一样的核心就是store『仓库』可以看做是一个容器 包含你的应用中的大部分的状态『state』
<span class="token number">1</span>. Vuex的状态存储是响应式的 store的状态发生变化 相应使用该状态的组件也会得到更新
<span class="token number">2</span>. 改变state的唯一途径只有显式提交『commit』 mutation
<span class="token number">3</span>. 组件触发『dispatch』异步事件或动作actions actions再将这个动作提交给mutations 然后再去改变state的状态 改变之后就会重新渲染到组件中 展示更新后的新数据
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>各个模块：
<span class="token number">1</span>. Vue Components：Vue组件 html页面负责接收用户操作等交互 执行dispatch触发对应的action来进行回应
<span class="token number">2</span>. dispatch：操作行为触发方法 是唯一能执行action的方法
<span class="token number">3</span>. actions：操作行为处理模块 负责处理所有接收到的交互行为 包括同步异步操作 支持多个同名方法 按照注册的顺序依次触发
   可以在里面请求后台API 触发其他action 以及提交mutation的操作
   提供了promise的封装 以及action的链式触发
<span class="token number">4</span>. commit：状态改变提交操作方法 对mutation进行提交 是唯一能够执行mutation的方法
<span class="token number">5</span>. mutations：状态改变操作方法 是Vuex修改state的唯一推荐方法 方法名全局唯一
<span class="token number">6</span>. state：页面状态管理容器对象 集中存储vue components中data对象的零散数据 全局唯一 以进行统一的状态管理
<span class="token number">7</span>. getters：state对象读取方法
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>Vuex 实现了⼀个单向数据流，在全局拥有⼀个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调⽤获取 State 数据的更新。⽽当所有异步操作<span class="token punctuation">(</span>常⻅于调⽤后端接⼝异步获取更新数据<span class="token punctuation">)</span>或批量的同步操作需要⾛ Action ，但 Action 也是⽆法直接修改 State 的，还是需要通过Mutation 来修改State的数据。最后，根据State 的变化，渲染到视图上。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_5-vuex中action和mutation的区别"><a href="#_5-vuex中action和mutation的区别" class="header-anchor">#</a> 5. <code>Vuex</code>中<code>action</code>和<code>mutation</code>的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. mutation中的操作是一系列的同步函数 用于修改state中的变量的状态。要使用Vuex时需要通过commit来提交需要操作的内容。接收第一个参数是state
<span class="token number">2</span>. action的不同点在于：
   action中可以包含任意异步操作
   不可以直接修改state中的变量的状态 需要提交mutation 由mutation来更改state变量状态
   接收一个与store实例具有相同属性和方法是context对象 所以可以调用commit方法来提交 或者通过context.state等进行访问
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 使用</span>
<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">state</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">mutations</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token function">increment</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            state<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">actions</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token function">increment</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. mutation专注于修改state变量的状态 action主要负责的是业务代码 异步请求，不能直接操作state
<span class="token number">2</span>. mutation必须同步执行 action可以异步
<span class="token number">3</span>. 视图更新的时候 先触发action action再触发mutation
<span class="token number">4</span>. 参数 mutation的参数是state 包含store中的数据 
       action的参数是context 包含store getters等
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_6-redux-和-vuex-有什么区别-它们的共同思想"><a href="#_6-redux-和-vuex-有什么区别-它们的共同思想" class="header-anchor">#</a> 6. <code>Redux</code> 和 <code>Vuex</code> 有什么区别，它们的共同思想</h2> <h4 id="redux和-vuex区别"><a href="#redux和-vuex区别" class="header-anchor">#</a> <code>Redux</code>和 <code>Vuex</code>区别</h4> <ol><li><p><code>Vuex</code>改进了<code>Redux</code>中的<code>Action</code>和<code>Reducer</code>函数，以<code>mutations</code>变化函数取代<code>Reducer</code>，⽆需<code>switch</code>，只需在对应的<code>mutation</code>函数⾥改变<code>state</code>值即可</p></li> <li><p><code>Vuex</code>由于<code>Vue</code>⾃动重新渲染的特性，⽆需订阅重新渲染函数，只要⽣成新的<code>State</code>即可</p></li> <li><p><code>Vuex</code>数据流的顺序是∶<code>View</code>调⽤<code>store.commit</code>提交对应的请求到<code>Store</code>中对应的<code>mutation</code>函数==&gt;<code>store</code>改变（<code>vue</code>检测到数据变化⾃动渲染）</p></li></ol> <blockquote><p>通俗点理解就是，<code>vuex</code>弱化 <code>dispatch</code>，通过<code>commit</code>进⾏ <code>store</code>状态的⼀次更变;</p> <p>​                              取消了<code>action</code>概念，不必传⼊特定的 <code>action</code>形式进⾏指定变更;</p> <p>​                              弱化<code>reducer</code>，基于<code>commit</code>参数直接对数据进⾏转变，使得框架更加简易;</p></blockquote> <h4 id="共同思想"><a href="#共同思想" class="header-anchor">#</a> 共同思想</h4> <ol><li><p><strong>单—的数据源</strong></p></li> <li><p><strong>变化可以预测</strong></p></li></ol> <p>本质上：<code>redux</code>与<code>vuex</code>都是对<code>mvvm</code>思想的服务，将数据从视图中抽离的⼀种⽅案;</p> <p>形式上：<code>vuex</code>借鉴了<code>redux</code>，将<code>store</code>作为全局的数据中⼼，进⾏<code>mode</code>管理;</p> <h2 id="_7-vue3-0有什么更新"><a href="#_7-vue3-0有什么更新" class="header-anchor">#</a> 7. <code>Vue3.0</code>有什么更新</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 监测机制的改变：
   消除了Vue2中基于Object.defineProperty的实现所存在的限制 带来了基于代理Proxy的observer实现
   
<span class="token number">2</span>. 只能监测属性 不能监测对象
   监测属性的添加和删除 数组索引和长度的变更 支持 Map Set和弱引用
   
<span class="token number">3</span>. 插槽
   vue2.x的机制导致作用域插槽改变就会使父组件重新渲染
   vue3.0将作用域插槽改为函数的形式 只会重新渲染子组件 提高性能

<span class="token number">4</span>. render函数
   vue3.0进行更改使用api生成vdom
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_8-defineproperty和proxy的区别"><a href="#_8-defineproperty和proxy的区别" class="header-anchor">#</a> 8. <code>defineProperty</code>和<code>proxy</code>的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>Vue2中在实例初始化的时候会遍历data中的所有属性 并使用Object.defineProperty把这些属性都转为setter getter 这样当追踪数据发生变化的时候 setter会被自动调用 Object.defineProperty是ES5的一个特性

出现的问题：
<span class="token number">1</span>. 添加或删除对象的属性的时候 vue2是检测不到的 因为这个新操作没有在初始化的时候添加到响应式处理上
<span class="token number">2</span>. 无法监控到数组下标和长度的变化
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>Vue3使用proxy来监控数据的变化 Proxy是ES6提供的功能 是为了定义基本操作的自定义行为『属性查找 赋值 枚举 函数调用等』

相对于Object.defineProperty的特点：
<span class="token number">1</span>. Proxy可以直接代理整个对象而非对象的属性 这样就可以只需一层代理就可以监听同级结构下的 所有属性变化包括新增属性和删除的属性
<span class="token number">2</span>. Proxy也可以监听数组的变化
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_9-虚拟dom的理解"><a href="#_9-虚拟dom的理解" class="header-anchor">#</a> 9 虚拟<code>DOM</code>的理解</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 本质上来说 虚拟DOM是DOM的抽象 是一个JavaScript对象 通过对象的方式来表示DOM结构 是更加轻量级的对DOM的描述

<span class="token number">2</span>. 好处：
   将页面的状态抽象为JS对象的形式 配合不同的渲染工具 使跨平台渲染成为可能 通过事务处理机制 将多次DOM修改的结果一次性的更新到页面上 从而有效减少页面渲染的次数 减少修改DOM的重绘重排次数 提高渲染性能。

<span class="token number">3</span>. 使用原理：解析过程
   在代码渲染到页面之前 vue会将代码转换为一个对象『虚拟DOM』 以对象的形式来描述真实的DOM结构 最终渲染到DOM页面上
   当每次数据发生变化前 虚拟DOM都会缓存一份 变化之时 现在的虚拟DOM会和缓存的虚拟DOM进行比较 使用vue内部封装的diff算法来进行比较 渲染时修改改变的变化 原先没有发生的改变的通过原先的数据进行渲染
   
『题外话』
一个元素对象就包含TagName props Children等属性 虚拟DOM就是由很多元素对象组合的一个JS对象树
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token comment">&lt;!-- 旧页面内容 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>list<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>哈哈<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>呵呵<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 新页面内容 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>list<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>哈哈<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>今天是个好日子<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> oldVDOM <span class="token operator">=</span> <span class="token punctuation">{</span>             <span class="token comment">// 旧虚拟DOM</span>
    <span class="token literal-property property">tagName</span><span class="token operator">:</span> <span class="token string">'ul'</span><span class="token punctuation">,</span>          <span class="token comment">// 标签名</span>
    <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>                <span class="token comment">// 标签属性</span>
        <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'list'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span>             <span class="token comment">// 标签子节点</span>
        <span class="token punctuation">{</span>
            <span class="token literal-property property">tagName</span><span class="token operator">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'哈哈'</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
            <span class="token literal-property property">tagName</span><span class="token operator">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'呵呵'</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> oldVDOM <span class="token operator">=</span> <span class="token punctuation">{</span>            <span class="token comment">// 新虚拟DOM</span>
    <span class="token literal-property property">tagName</span><span class="token operator">:</span> <span class="token string">'ul'</span><span class="token punctuation">,</span>         <span class="token comment">// 标签名</span>
    <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>               <span class="token comment">// 标签属性</span>
        <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">'list'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token comment">// 标签子节点</span>
        <span class="token punctuation">{</span>
            <span class="token literal-property property">tagName</span><span class="token operator">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'哈哈'</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
            <span class="token literal-property property">tagName</span><span class="token operator">:</span> <span class="token string">'li'</span><span class="token punctuation">,</span> <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'item'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'今天是个好日子'</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>此时 就出现两个新旧虚拟<code>DOM</code> 这个时候的新虚拟<code>DOM</code>是数据的最新状态</p> <p>但是如果我们直接拿新虚拟<code>DOM</code>去渲染成真实DOM时 效率并不会比直接操作真实<code>DOM</code>高</p> <p>错误：虚拟<code>DOM</code>比真实<code>DOM</code>快</p> <p>正确：虚拟<code>DOM</code>算法操作真实<code>DOM</code>的性能高于直接操作真实<code>DOM</code></p></blockquote> <h2 id="_10-diff算法的原理"><a href="#_10-diff算法的原理" class="header-anchor">#</a> 10 <code>diff</code>算法的原理</h2> <p><a href="https://juejin.cn/post/6994959998283907102" target="_blank" rel="noopener noreferrer">15张图，20分钟吃透Diff算法核心原理，我说的！！！ - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>虚拟<code>DOM</code>+<code>diff</code>算法才能真正的提供性能</strong></p> <blockquote><p>如上的例子：如果使用<code>diff</code>算法 就会对比出 只有一个<code>li</code>标签发生了改变 才更新真实<code>DOM</code>只更新目标<code>li</code>标签  其他的节点都不变 就没有必要更新</p> <p>所以 <code>diff</code>算法其实就是查出这个 <code>li</code>标签的算法</p></blockquote> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>总结：
    Diff算法是一种对比算法 对比两者是新旧虚拟DOM 对比出是哪个虚拟节点更改了 找出这个虚拟节点 然后更新这个虚拟节点所对应的真实节点 而不用更新其他数据没发生过改变的节点 实现精准更新真实DOM 提高效率
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>原理：
<span class="token number">1</span>. 新旧对比的时候 只会在同层级进行比较 不会跨层级比较
<span class="token number">2</span>. diff算法是 深度优先算法  时间复杂度O<span class="token punctuation">(</span>n<span class="token punctuation">)</span>

对比流程：
<span class="token number">1</span>. 当数据更改时 会触发setter 并通过Dep.notify去通知所有订阅者
   订阅者就会调用patch方法 给真实DOM打补丁 更新相应视图
<span class="token number">2</span>. patch方法：对比同层的虚拟节点是否为同一类型的标签『sameVnode方法』
   不同：就直接将整个节点替换为新虚拟节点
   相同：进行执行『patchVnode』进行深层比对

注: <span class="token number">1</span>. sameVnode方法: 是patch方法的关键性一步 
    <span class="token number">2</span>. patchVnode方法: 判断是否指向同一个对象 文本节点 子节点等 如果两者都有子节点 就执行 updateChildren进行比较子节点
    <span class="token number">3</span>. updateChildren方法: patchVnode中最重要的一个方法 新旧虚拟节点的子节点对比『首尾指针法』
       比较情况：
           oldS <span class="token operator">==</span><span class="token operator">&gt;</span> newS『首首』
           oldS <span class="token operator">==</span><span class="token operator">&gt;</span> newE『首尾』
           oldE <span class="token operator">==</span><span class="token operator">&gt;</span> newS『尾首』 
           oldE <span class="token operator">==</span><span class="token operator">&gt;</span> newE『尾尾』 
           使用新旧节点的不同key值去比较对比 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/1db54647698e4c76b6fc38a02067ad72~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>为什么v-for循环不建议index作为key
举例：在列表最前面插入一个li标签 整个列表都将index作为key

<span class="token number">1</span>. 在进行子节点的diff算法过程中 会进行旧首和新首节点的对比 key都为0 就会更新为新dom树的文本 
   最后新增一个节点居然是原本就有的节点 就因为key值之前没有出现过 所以最终就是所有li标签都更新了
  
<span class="token number">2</span>. 所以最好使用一个独一无二的值作为key 这么做的话原有节点的key值就是不变的 更新前后的key值一样 内容相同 就会复用
   如果新增节点 原来是没有它的key值的 那就会被当做新的节点 增加到真实DOM上
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h1 id="_2023年4月19日-星期三"><a href="#_2023年4月19日-星期三" class="header-anchor">#</a> 2023年4月19日 星期三</h1> <h2 id="_1-微信小程序的生命周期函数有哪些"><a href="#_1-微信小程序的生命周期函数有哪些" class="header-anchor">#</a> 1. 微信小程序的生命周期函数有哪些</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>生命周期：实质上是一堆在特定时期执行的函数
<span class="token number">1</span>. 应用的生命周期
   小程序的生命周期是在app.js中调用的 通过App函数来注册一个小程序
   onLaunch 小程序初始化完成时触发 全局只触发一次
   onShow   小程序启动 或从后台进入前台显示时触发
   onHide   进入后台触发
   onError
   onPageNotFount
   onUnhandleRejected  有未处理的Promise拒绝时触发
   onThemeChange
   
<span class="token number">2</span>. 页面的生命周期
   当切换到一个新的页面时 就会调用的生命周期函数 通过App函数来注册一个页面
   onLoad: 监听页面加载 发送请求获取数据
   onShow: 监听页面显示 请求数据
   onReady: 页面初次渲染完成 获取页面元素『少用』
   onHide: 页面隐藏
   onUnload: 页面卸载
   
<span class="token number">3</span>. 组件的生命周期
   指的是组件自身的一些函数 这些函数在特殊的时间点或遇到一些特殊的框架事件被自动触发 通过Component进行注册组件
   created   页面加载
   attached  页面显示
   ready     页面初次渲染完成
   moved     页面隐藏完成
   datached  页面卸载
   error     组件方法出错
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h2 id="_2-小程序路由跳转"><a href="#_2-小程序路由跳转" class="header-anchor">#</a> 2. 小程序路由跳转</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>wx.navigateTo<span class="token punctuation">(</span>Object<span class="token punctuation">)</span>: 保留当前页面 跳转到非TabBar页面 可以Back返回  『新页面入栈』
wx.redirectTo<span class="token punctuation">(</span>Object<span class="token punctuation">)</span>: 重定向 关闭当前页面 跳转非TabBar 但返回页面需要重新加载 增加了显示时间 『当前出栈 新页面入栈』
wx.switchTab<span class="token punctuation">(</span>Object<span class="token punctuation">)</span>: 跳转到TabBar页面 关闭所有非页面 不能带参数      『全部出栈 留下新的tab页面』
wx.navigateBack<span class="token punctuation">(</span>Object<span class="token punctuation">)</span>     『页面不断出栈 直到目标返回页 新页面入栈』
wx.reLaunch<span class="token punctuation">(</span>Object<span class="token punctuation">)</span>: 关闭所有页面，打开到应用内的某个页面             『页面全部出栈 只留下新页面』
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h1 id="_2023年4月23日-星期日"><a href="#_2023年4月23日-星期日" class="header-anchor">#</a> 2023年4月23日 星期日</h1> <h2 id="_1-进程和线程的区别"><a href="#_1-进程和线程的区别" class="header-anchor">#</a> 1. 进程和线程的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 资源：
   进程是CPU资源分配的最小单位 可以拥有资源和运行程序的最小单位
   线程是CPU调度的最小单位 是建立在进程基础上的一次程序运行单位 一个进程可以有多个线程
   
<span class="token number">2</span>. 独立应用：
   进程可以作为一个独立应用使用 线程不可以
   
<span class="token number">3</span>. 通信：
   进程间是相互隔离的 只能借助进程间通信
   线程是共享同一个进程的资源 所以可以直接进行通信
   
<span class="token number">4</span>. 调度
   进程切换比线程切换开销更大
   
<span class="token number">5</span>. 系统开销
   创建或撤销进程的时候 操作系统都要为其分配或回收资源 开销远远大于线程的创建与撤销
   线程切换的时候只需保存和设置少量寄存器内容 开销较小
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>浏览器的进程：
<span class="token number">1</span>. 浏览器进程：界面显示 用户交互 存储等
<span class="token number">2</span>. 网络进程：负责网络资源的加载
<span class="token number">3</span>. GPU进程：
<span class="token number">4</span>. 渲染进程：将html+css+js转换为用户可以与之交互的网页
            排版引擎和JavaScript引擎都运行在该进程中
            会为浏览器中每个tab标签创建一个渲染进程
<span class="token number">5</span>. 插件进程
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-sh line-numbers-mode"><pre class="language-sh"><code>渲染进程中的线程：
<span class="token number">1</span>. GUI渲染线程：解析html+css 构建dom树和cssom树 构建渲染树和绘制页面。当引起重绘和回流，线程就会执行。
   和JS引擎线程是互斥的 一方执行另一方挂起
<span class="token number">2</span>. JS引擎线程：负责处理JavaScript脚本程序 解析JavaScript脚本
   如果JS执行的时间过长 会造成页面的渲染不连贯 导致页面渲染加载阻塞
<span class="token number">3</span>. 事件触发线程 当对应的事件符合触发条件就会被添加到待处理队列的队尾 等待JS引擎的处理
<span class="token number">4</span>. 定时器触发线程：定时器的任务在设定的时间不一定能够准时执行 而是在指定时间点将任务添加到事件队列中 不能小于4ms
<span class="token number">5</span>. 异步http请求线程：将回调函数放入事件队列中 等待JS引擎空闲后执行
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>注意</strong>：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执⾏）；</p> <h2 id="_2-进程之前的通信方式"><a href="#_2-进程之前的通信方式" class="header-anchor">#</a> 2. 进程之前的通信方式</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>管道通信：
<span class="token number">1</span>. 最基本的进程间通信机制。
<span class="token number">2</span>. 操作系统在内核中开辟的一段缓冲区 进程1可以将需要交互的数据拷贝到这段缓存区 进程2就可以读取了
<span class="token number">3</span>. 特点：
   只能单向通信
   只能有血缘关系的进程进行通信
   依赖文件系统  管道内部提供了同步进制
   
消息队列通信：
<span class="token number">1</span>. 消息队列就是一个消息的列表。提供了一种从一个进程向另一个进程发送一个数据块的方法。
<span class="token number">2</span>. 使用消息队列可能会受到数据块最大长度的限制约束等
<span class="token number">3</span>. 消息的读取 是从一个进程拷贝到另一个进程

信号量通信
<span class="token number">1</span>. 共享内存最大的问题就是多线程竞争内存的问题 类似线程安全问题
<span class="token number">2</span>. 信号量本质是一个计数器 实现进程之间的互斥与同步
   当有进程访问内存1时 就将信号量的值设为0
   那么其他进程就知道内存1已经有进程在访问了 其他的进程就访问不了
   
信号通信
<span class="token number">1</span>. Unix系统中最古老的进程间通信的方法之一

共享内存通信
<span class="token number">1</span>. 映射一段能被其他进程所访问的内存 这段共享内存可以被多个进程调问
<span class="token number">2</span>. 是最快的IPC方式？

套接字通信
<span class="token number">1</span>. 上面的管道 消息队列 信号量 信号 共享内存都是多个进程在同一台主机之间的通信。
<span class="token number">2</span>. Socket通信方式：
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h2 id="_3-死锁产生的原因-如果解决死锁的问题"><a href="#_3-死锁产生的原因-如果解决死锁的问题" class="header-anchor">#</a> 3. 死锁产⽣的原因？ 如果解决死锁的问题？</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token number">1</span>. 概念：死锁是指多个进程在运行过程中因为争夺资源而造成的一种僵局。当进程处于这种状态时 若无外力作用 它们都无法向前推进

<span class="token number">2</span>. 资源包括：
   可剥夺资源：CPU 主存等
   不可剥夺资源： 磁带机 打印机等
   
<span class="token number">3</span>. 原因： 
   <span class="token number">1</span>. 竞争不可剥夺资源：进程p1已占用了打印机 进程p2继续要求打印机打印将造成阻塞
   <span class="token number">2</span>. 竞争临时资源：包括硬件账单 信号 消息 缓存区中的消息等 消息通信顺序操作不当 就会产生死锁
   <span class="token number">3</span>. 进程间推进顺序 非法：若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发⽣死锁。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230423223104534.png" alt="image-20230423223104534"></p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>预防死锁
<span class="token number">1</span>. 资源一次性分配
<span class="token number">2</span>. 如果该进程得不到其中一个资源的分配 那也不分配给它其他的资源
<span class="token number">3</span>. 当某个进程得到了部分资源 但得不到其他资源 则释放已占有的资源
<span class="token number">4</span>. 给每类资源赋予一个编号 每一个进程按照编号顺序来请求资源 释放则相反
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_4-对浏览器的缓存机制的理解"><a href="#_4-对浏览器的缓存机制的理解" class="header-anchor">#</a> 4. 对浏览器的缓存机制的理解</h2> <h2 id="_5-协商缓存和强缓存的区别"><a href="#_5-协商缓存和强缓存的区别" class="header-anchor">#</a> 5. 协商缓存和强缓存的区别</h2> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>使⽤强缓存策略时，如果缓存资源有效，则直接使⽤缓存资源，不必再向服务器发起请求。
<span class="token number">1</span>. 主要就是判断是否过期；
   服务器在响应头添加Expires属性来制定资源的过期时间 在时间内可以被缓存 不必发送请求『HTTP1.0』
   Cache-Control属性提供了对资源的缓存更精确的控制 其中有一个max-age<span class="token operator">=</span>是设置缓存的最大有效期 单位为妙 『HTTP1.1』
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/toxicDocs/toxicBlogs/interview/html5.html">
          html5
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:0;" data-v-6986a797 data-v-6f8f7dda></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/toxicDocs/assets/js/app.57a67b61.js" defer></script><script src="/toxicDocs/assets/js/3.38eb45c0.js" defer></script><script src="/toxicDocs/assets/js/1.eb5625cb.js" defer></script><script src="/toxicDocs/assets/js/40.23bfa2cb.js" defer></script>
  </body>
</html>
