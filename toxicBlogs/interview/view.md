## 一. 专业技能点

### 1.1 CSS 预处理器

> 用来增强和扩展CSS的功能。允许使用变量，嵌套和混入等等高级特性以更简洁和更可维护的方式来编写样式。

1. 参考链接：[Sass和Less（预处理器）「建议收藏」](https://cloud.tencent.com/developer/article/2123846)

2. 语法：Sass有两种语法格式，新版以`.scss`结尾

   ​		   Less类似CSS，使用大括号和分号，以`.less`结尾

3. **变量**：Sass使用 $ 符号定义变量，Less使用 @ 符号。

4. **插值**：Sass使用 `#{}`

   ​	       Less使用 `@{}` 将定义的值放在括号里 （less中全是@）

5. **嵌套**：都支持选择器和伪类嵌套；Sass还支持属性嵌套。

6. **作用域**：Less采取  <u>就近原则</u>，优先使用大括号里面的变量。            

   ​			  Sass是 <u>从外层作用域到内层</u>，除非在内层定义覆盖，否则就使用外层作用域的变量值。

7. **混合 mixin**：都支持混合，将一组CSS规则封装为可重用的模块。        

   ​				    Less支持类选择器和ID选择器；如果不想编译出来就加括号。

   ​                    Sass使用`@mixin`和`@include`进行使用。

8. 继承：Sass使用`@extend 样式`；Less使用`&:extend(样式)`。

   ​          编译后都会保留该样式。Sass在要被继承的样式前加`%`，编译后不会保留。

9. 支持自定义运算：Sass不允许不同单位，会报错。Less可以，以第一个为准。

10. 条件语句：Sass是使用`@if @else`。

    ​                  Less条件判断都是使用`when`。

11. 循环语句：`@for @while @each`

12. 导入：都是使用`@import`

[CSS预处理器 - 飞书](https://pirdr5x8i5.feishu.cn/wiki/O9MSwNF3vigaeKkcc6ScxJ4lnLw?fromScene=spaceOverview)

### 1.2 后处理器

本人只在开发 H5 端项目时接触过 PostCSS 该后处理器。

—— 可以使用JavaScript工具和代码来转换CSS代码的工具。PostCSS更注重于对CSS的转换和优化。

我们在开发中可以 将固定宽度的尺寸比如 px 转为可随宽度变化而等比例伸缩的视图尺寸 rem。

1. px：绝对长度单位。
2. rem：相对 html 根元素的字体大小的值。**总是相对根元素的**
3. em：相对父级元素的字体尺寸大小。任意浏览器的默认字体高都是 16px。
4. vh：窗口高度。在桌面端，指的是浏览器的可视区域。移动端指的就是布局视口。
5. vw：窗口宽度。



### 1.3 H5 和 C3

#### 1.3.1 语义化

1. 语义化的意思就是 根据 html 页面内容的结构化使用合适的标签 —— 用正确的标签做正确的事情

2. 优点：

  有利于SEO，对机器友好，语义化标签下有更丰富的表现力，更适合搜索引擎的爬虫爬取有效信息。

  对开发者友好，增强了页面内容的可读性，结构更加清晰，有利于开发与维护。

3. H5的语义化标签有

  Header Footer Aside Nav Article Section Main



#### 1.3.2 盒模型

盒模型包括IE盒模型（怪异盒模型） 和 标准盒模型。

属性：`box-sizing: content-box(IE)  border-box(standard)`

组成： content（width height）   padding    margin     border

**区别：**

1. IE盒模型设置的 width 和 height 就是占据页面的宽高 包括了content padding border
2. 标准盒模型设置的 width 和 heigh t就是单纯的 content 内容 实际上的宽高还要大于设置的，包括了content+padding+border

当然 外边距就不包括在里面啦



#### 1.3.3 Flex布局

1. 概念

   Flex 布局是 Flexible box 的缩写，意思为弹性布局，用来给盒模型提供最大的灵活性。

   行内元素也可以使用弹性布局。

   采用 Flex 布局的元素，被称为Flex容器，简称容器。所有的子元素自动成为容器成员称为 Flex 项目。

2. 轴线
   
   Flex 容器默认存在两根轴：水平的主轴以及垂直的交叉轴。
   
   项目默认沿着水平主轴排列。可以使用 `flex-direction` 来指定主轴的方向。
   
   可以使⽤`justify-content`来指定元素在主轴上的排列⽅式，`align-items`来指定元素在交叉轴上的排列⽅式。
   
   可以使⽤`flex-wrap`来规定当⼀⾏排列不下时的换⾏⽅式。
   
   对于容器中的项⽬，可以使⽤`order`属性来指定项⽬的排列顺序.
   
   还可以使⽤`flex-grow`来指定当排列空间有剩余的时候，项⽬的放⼤⽐例。
   
   还可以使⽤`flex-shrink`来指定当排列空间不⾜时，项⽬的缩⼩⽐例
   
3. 容器属性
   
   flex-direction
   
   flex-wrap
   
   flex-flow
   
   **justify-content**
   
   **align-items**
   
   align-contents
   
4. 项目属性
   
   order            项目的排列顺序 数值越小越靠前
   
   flex-grow      定义放大比例
   
   flex-shrink    定义缩小比例
   
   flex-basis      默认auto即本来大小
   
   **flex               grow | shrink | basis的缩写**
   
   align-self



#### 1.3.4 Web存储

**LocalStorage**：`HTML5`新方法，IE8及以上浏览器都兼容

- 生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的
- 大小：5M（跟浏览器厂商有关系）
- `localStorage`本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡



**SessionStorage**

+ 和 `localStorage`使用方法基本一致。
+ 唯一不同的是生命周期，一旦页面（会话）关闭，`sessionStorage` 将会删除数据。



**Cookie**

+ 类型为「小型文本文件」
+ 某些网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 `HTTP`无状态导致的问题。
+ `cookie`的删除，最常用的方法就是给`cookie`设置一个过期的事件，这样`cookie`过期后会被浏览器删除。
+ 主要属性有：
  - Expires 用于设置 Cookie 的过期时间 `Expires=Wed, 21 Oct 2015 07:28:00 GMT`
  - Max-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比`Expires`高



#### 1.3.5 SSE

`server-sent events`：服务器推送事件。是一种服务器向浏览器推送消息的技术。是一种单向通道。

1. 是`H5`的一个通信的API，包括`HTTP`协议和 `EventSource`对象。
2. 本质是浏览器发起`HTTP`请求，服务器在收到请求后返回状态和数据，且请求头`headers`附带：

```
Content-Type: text/event-stream # 事件流返回
Cache-Control: no-cache # 浏览器不缓存，可以实时的显示服务器发送的数据
Connection: keep-alive # TCP连接要一直保持开启状态
```

> 由服务器端向客户端推送数据有许多解决方案：包括轮询，websocket，以及H5的SSE。

一般来说：只能浏览器向服务器发起请求，服务器不能主动给浏览器推送数据。除非服务器向浏览器表明：发送的是流信息，浏览器就不会关闭HTTP连接，会一直等待服务器发送新的数据流过来。

SSE就是利用这种机制，使用流信息向客户端推送数据。

具体来说，在使用SSE技术时，客户端会通过建立与服务器的HTTP连接来监听事件流。

当服务器有事件需要推送时，服务器会通过HTTP连接将事件流发送到客户端，然后客户端的JavaScript就可以解析这些事件并进行处理。

以聊天应用为例，我们可以设置一个EventSource对象来监听特定的url，当有新的消息到达时，我们就可以通过解析服务器发送的数据来获取这些消息，并将它们追加到对话框中。实现的对话消息的流式返回。



####  1.3.5 WebSocket

WebSocket，是一种网络传输协议，位于`OSI`模型的应用层。

可在单个`TCP`连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通讯。

**客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。**

**之后双方都能主动向对方发送或接受数据。**

引入`ws`和`wss`分别代表明文和密文的`websocket`协议，且默认端口使用80或443，几乎与`http`一致。



**与SSE的区别：**

|              | SSE                      | WebSocket                                                 |
| ------------ | ------------------------ | --------------------------------------------------------- |
| 数据推送方向 | 服务器向客户端的单向通信 | 允许实时的双向数据交换                                    |
| 连接建立方式 | HTTP的长连接，单向通信   | WebSocket 协议，ws \| wss。**全双工通信**                 |
| 兼容性       | 大多数浏览器中使用       |                                                           |
| 适用场景     | 新闻实时推送             | 聊天应用和多人协同编辑等                                  |
| 自动重连     | 需要客户端重新发起请求   | **原生WebSocket 不会断线重连** <br />需要自己封装心跳响应 |
| 消息格式     | 文本格式                 | 文本格式和二进制的消息                                    |



#### 1.3.6 动画

`css`实现动画的方式，有如下几种：

- transition 实现渐变动画
- transform 转变动画
  - translate：位移
  - scale：缩放
  - rotate：旋转
  - skew：倾斜
  - 一般配合`transition`过度使用
- animation 实现自定义动画
  - 通过 `@keyframes` 来定义关键帧



#### 1.3.7 响应式布局

> 是一种网络页面设计布局。页面的设计与开发根据设备环境进行响应与调整。

实现响应式布局的方式有如下：

- 媒体查询
- 百分比
- vw/vh
- rem

```css
@media screen (min-width: 375px) and (max-width: 600px) {}
```

```js
// 动态为根元素设置字体大小
function init () {
    // 获取屏幕宽度
    var width = document.documentElement.clientWidth
    // 设置根元素字体大小。此时为宽的10等分
    document.documentElement.style.fontSize = width / 10 + 'px'
}

//首次加载应用，设置一次
init()
// 监听手机旋转的事件的时机，重新设置
window.addEventListener('orientationchange', init)
// 监听手机窗口变化，重新设置
window.addEventListener('resize', init)

// 无论设备可视窗口如何变化，始终设置rem为width的1/10，实现了百分比布局
```



### 1.4 JavaScript

#### 1.4.1 原型

> `JavaScript` 常被描述为一种基于原型的语言——每个对象拥有一个原型对象。
>
> 原型：—— 每个构造器函数都有一个特殊的属性叫做原型 `prototype` 。所有通过该构造器实例化的对象，都有一个属性 `__proto_`指向该`prototype`对象。
>
> 原型链：—— 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，
>
> 依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

但：这些原型上的属性和方法 都是定义在构造器函数的原型对象 prototype 上的，而不是在实例本身。



#### 1.4.2 闭包

> 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。
>
> 任何闭包的使用场景都离不开这两点：
>
> - 创建私有变量
> - 延长变量的生命周期

柯里化函数就是闭包的一个使用场景。

柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用。

比如：计算有相同宽度但是 <u>不同高度</u> 的长方形的面积。

```js
// 我们可以使用闭包柯里化这个计算面积的函数
function getArea(width) {
    return height => {
        return width * height
    }
}
```



#### 1.4.3 事件循环

> 前提：首先，`JavaScript`是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，**而实现单线程非阻塞的方法就是事件循环**。

在`JavaScript`中，所有的任务都可以分为

- 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行
- 异步任务：异步执行的任务，比如`ajax`网络请求，`setTimeout`定时函数等。

代码执行过程中：同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入Event Table并注册函数。

当异步任务指定的事情完成时，Event Table会将这个函数移入Event Queue。

主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。

上述过程会不断重复，也就是常说的Event Loop(事件循环)。



#### 1.4.4 继承

使用类继承 `Class`  --- `extends`

在继承时，可以重新定义父级的属性和方法

```js
class Truck extends Car{
    constructor(color,speed){
        super(color,speed)
        this.color = "black" // 覆盖
        this.Container = true // 货箱
    }
}
```

 ![img](https://gitee.com/zhizhu_wlz/image-for-md/raw/master/202405280253027.png)

#### 1.4.5 事件委托

> 事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素
>
> 事件流会经过三个阶段： 捕获阶段 > 目标阶段 > 冒泡阶段，而事件委托就是在冒泡阶段完成。

优点：

- 减少整个页面所需的内存，提升整体性能
- 动态绑定，减少重复工作

缺点：

- `focus`、`blur`这些事件没有事件冒泡机制，所以无法进行委托绑定事件
- `mousemove`、`mouseout`这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的



#### 1.4.6 防抖节流

> 本质上是优化高频率执行代码的一种手段

如：浏览器的 `resize`、`scroll`事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能

- 防抖： n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时【**触发时重新计时**】
- 节流： n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 【**固定时间触发一次**】

**使用场景：**

防抖在连续的事件，只需触发一次回调的场景有：

- 搜索框搜索输入。只需用户最后一次输入完，再发送请求
- 手机号、邮箱验证输入检测
- 窗口大小`resize`。只需窗口调整完成后，计算窗口大小。防止重复渲染。

节流在间隔一段时间执行一次回调的场景有：

- 滚动加载，加载更多或滚到底部监听
- 搜索框，搜索联想功能



#### 1.4.7 Promise











## 1. 模块与组件

### 1.1 模块与模块化

1. 模块即向外提供特定功能的JS程序，一般就是一个单独的JS文件。
2. 随着业务逻辑的增加，代码越多且复杂。
3. 通过拆分为不同的模块可以复用 JS，简化 JS 的编写，提高 JS 运行效率。

当整个应用的JS都以模块来编写的时候，这个应用就是一个模块化的应用。

### 1.2 组件与组件化

1. 组件即用来实现局部功能效果的代码和资源（html，css，js，images等）的集合。
2. 当一个界面的功能更加复杂时，使用组件来复用编写，简化项目编码，提高运行效率。

当应用是以多组件的方式实现的，这个应用就是一个组件化的应用。

