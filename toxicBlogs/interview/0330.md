---
title: 前端各类知识点
date: 2023-03-30
categories:
 - 面试
---



# 2023年3月30日 星期四

## 1. `src`和`href`的区别

```sh
src: source

1. 指向外部资源，指向的内容会被嵌入到当前标签所在的位置。
2. 一般是js脚本，图片资源或者 iframe 框架元素。
3. 当请求到src内容时，浏览器会暂停其他资源的下载和处理，直到该资源加载编译与执行完毕。
```

```sh
href: 超文本引用 HypeText Reference

1. 其实也是指向网络资源，它是建立起当前文档与其的链接。
2. 请求过程中是并行请求网络资源，不会暂停对其他资源的处理。
```

## 2. 对 `HTML` 语义化的理解

```sh
1. 语义化的意思就是 根据html页面内容的结构化使用合适的标签 —— 用正确的标签做正确的事情
2. 优点：
有利于SEO，对机器友好，语义化标签下有更丰富的表现力，更适合搜索引擎的爬虫爬取有效信息。
对开发者友好，增强了页面内容的可读性，结构更加清晰，有利于开发与维护。
3. H5的语义化标签有
Header Footer Aside Nav Article Section Main
```

## 3. script下defer和async的区别

```sh
相同点：
1. 首先这个script下的src在嵌入到当前标签页处的时候，本身是暂停其他资源，直到它加载编译执行结束
2. defer和async都能使script中的js脚本进行异步加载，不阻塞到页面其他资源的加载以及页面的解析
```

```sh
不同点：
1. 执行顺序：多个script标签内容的执行
   多个defer：加载顺序是不确定的；多个async：按照加载顺序执行
2. 脚本是否并行执行
   是分为加载+执行的嘛
   defer: js脚本的加载与页面解析是并行的。但是js脚本的执行是在所有元素解析完成之后才执行的。
   async: js脚本的加载与执行都是与页面一致并行的。
```

![image-20230330185841443](https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230330185841443.png)

## 4. `HTML5`新特性

```sh
1. 语义化标签
   Header
   Footer
   Aside
   Nav
   Section
   Main
   Article

2. input属性     表单类型 type      表单事件

3. API
   拖拽API       媒体标签  audio video
   画布API       SVG: 可伸缩矢量图形      地理API

4. localStorage
   sessionStorage
   
```



## 5. 行内元素，块级元素和空元素

```sh
1. 行内元素：span input strong img
2. 块级元素：div p  ol ul li  h1 ~ h6 
3. 空元素：br meta link  hr img input
没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签
```



## 6. `DocType`的作用

```sh
DocType是HTML5一种标准通用标记语言的文档声明类型，它规定浏览器以何种（html/xhtml)文档类型来解析文档。
不同的渲染模式会影响文档的css和js脚本的解析。
有两种不同的模式:
1. CSS1Compat: 标准模式
2. BackCompat: 怪异模式
```



## 7. `meta`标签

```sh
meta 标签中由name和content属性定义；用来描述网页文档的属性

1. charset 编码类型；描述html文档的编码类型

2. name:"keywords"  "descriptiom" "viewport" "robots"
有相对应的content属性。 robots ==> "all" "none" "index" "follow" "noindex" "nofollow"
index:文件可以被检索到    follow:页面上的链接可以被查询

3. http-equiv:"refresh" 页面重定向和刷新 搭配content 是 "0;url="
```



## 8. `web worker`的理解

```sh
前提: 因为JavaScript是单线程的，意味着所有任务都只能在一个线程中完成。

所以: webWorker就是为JavaScript创建多线程环境，允许JavaScript主线程创建了一个worker线程，分配一些任务在worker线程上运行。
主线程与webworker线程同时运行互不干扰，等到worker线程完成任务后，通过postMessage将结果返回给主线程。

好处: 一些计算密集型或高延迟的任务就被webWorker线程负担了，这样主线程主要负责UI交互就会更加流畅，不会被阻塞或拖慢
```

```sh
注意点：
1. 同源  worker线程运行的脚本与主线程运行的脚本必须同源
2. Dom操作  worker线程不能使用document,window等对象，但可以使用location和navigator
3. 只能运行网络资源 worker线程不能打开本地资源 file:// 
4. 通信联系 worker线程与主线程不在同一个上下文，通信只能通过消息传递
```

## 9. `title`/`h1` `b`/`strong` `i`/`em`

```sh
1. title是网站标题：可以直接告诉搜索引擎和用户网站的信息，显示在标题tab栏中
2. h1是文档中层次分明的标题，面向用户，更突出其视觉效果
```

```sh
1. b与i一致，都是样式但是没有实际含义；strong与em都可以通过css添加样式
2. b(bold)实体标签，用来给文字加粗            strong逻辑标签用来加强字符语气，表示内容重要
3. i(italic)实体标签，用来给文字倾斜——术语等  em(emphasis)是逻辑标签，强调文本内容
```



## 10 `SVG`和`Canvas`比较

```sh
基本内容
1. svg使用xml描述2d图像 canvas通过js绘制2d图形
2. svg是矢量图  canvas是位图，即放大后可以看到该图的像素点会出现锯齿状(依靠分辨率会失真)
3. svg支持事件绑定，但canvas只能给整个画布添加事件

1. svg绘制的图像是一个对象，如果对象属性发生改变，浏览器将重新绘制
   canvas绘制完毕，浏览器不再关注 直到位置发生改变才重新绘制
2. svg不适用图形密集，频繁操作Dom会减慢渲染的速度 Canvas可以
3. svg适合做地图 canvas渲染性能高,用来开发游戏或统计图
```

![01.jpg](https://gitee.com/zhizhu_wlz/image-for-md/raw/master/8eef29b6d6ab496ea356153dc86c4379~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

![image-20230331105729029](https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230331105729029.png)



## 11 `head`标签有什么用? 其中什么标签必不可少

```sh
1. head 标签用于定义文档的头部，是所有头部元素的容器。一般在其中定义脚本文件，直到浏览器在哪里找到样式表和文档的元信息。
2. 描述了各种各样的属性与信息 但都不会作为页面内容被用户看到
3. 一般在head中的标签： base meta title link script style
4. title是定义文档标题，唯一必需
```





# 2023年3月31日 星期五

## 1. `css`选择器及优先级

![img](https://pic3.zhimg.com/v2-b1a9fedf320754acb1d7766c6548d5f6_r.jpg)

> **权重记忆口诀**：从0开始，一个内联样式+1000，一个`id`选择器+100，一个属性选择器、`class`类选择器或者伪类+10，一个标签选择器，或者伪元素+1，通配符+0。

```sh
样式表来源不同：优先顺序为
内联 style="" > 内部 style{} > 外部 link > 浏览器用户自定义样式 > 浏览器默认样式
```



## 2. `display`的属性值及作用

|     属性值     |                           作用                           |
| :------------: | :------------------------------------------------------: |
|     `none`     |                元素不显示，从文档流中删除                |
|    `block`     |    块元素类型，宽度为父元素宽度，可设置宽高。换行显示    |
|    `inline`    | 行元素类型，宽度为自身内容宽度。不可设置宽高。不换行显示 |
| `inline-block` |  行元素类型。宽度为自身内容宽度。可设置宽高。不换行显示  |
|   `inherit`    |                继承父元素的`display`属性                 |
|  `list-item`   |                                                          |
|    `table`     |                                                          |



## 3. `display`的`block`、`inline`和`inline-block`的区别

```sh
1. block 会独占一行，多个元素会另起一行，可以设置width height padding margin
2. inline 不会独占一行，width就是元素本身内容宽度，设置width height无效。padding和margin只能是指水平方向，垂直方向不起效果
3. inline-block 不会独占一行 但可以设置width height padding margin
                将对象设置为行内元素，但对象的内容作为block呈现
```



## 4. 隐藏元素的方法有哪些

```sh
前提：
0. 渲染 网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断的触发重排和重绘
1. 重排 重新生成布局 重新排列元素 但重排之后将重新绘制受到重排影响的部分
2. 重绘 某些元素的外观被改变 如填充颜色等 仅仅改变外观，是不会引起网页重新布局的
结论：
1. 重绘不一定导致重排 重排一定导致重绘
2. 都会影响性能，但是重排会付出高额的性能代价，应该尽量避免
```

 [重排(reflow)和重绘(repaint) - 掘金 (juejin.cn)](https://juejin.cn/post/6844904083212468238)

![image](https://gitee.com/zhizhu_wlz/image-for-md/raw/master/170af501e710ce67~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

```sh
页面生成的过程：
1. HTML解析器将HTML解析为 DOM树
2. CSS解析器将CSS解析为 CSSOM树
3. 结合DOM和CSSOM 生成一颗渲染树
4. 渲染树生成布局（flow）浏览器在屏幕上画出节点
5. 将布局绘制（paint）在屏幕上 显示出整个页面
4+5. 就是通常所说的渲染
```

```sh
常规方法：
1. display:none;   结构消失，会触发重排和重绘
   彻底的隐藏了元素，不占据空间，不影响布局，响应事件失效
2. opacity:0;      不触发重排和重绘
   只是透明度设置为0，在页面上看不到，但仍占据空间也可响应事件
   会被读屏软件阅读，像其他元素一样
3. visibility:hidden;       触发重绘
   类似opacity属性，在页面上看不到但仍占据空间。但不响应交互事件
   此外也不会被读屏软件读取内容
```

```sh
逃逸视窗
1. position+left+top  超大父边距将元素抛出视图 定位本身脱离文档流所以不占据空间
2. translate(-9999px) 会占据空间，不过元素不在视窗内无法交互 （对行内元素无效）
3. transform:scale(0)/skew(90deg); 2d变换隐藏 占据空间不可交互   （对行内元素无效）
4. clip-path:circle(0px) 利用可裁剪创建元素的可显示区域，区域外会隐藏 不可交互
```

```sh
1. z-index  层叠上下文在合适的情况遮挡住元素
2. 压缩空间
   height:0;width:0;padding:0;margin:0;border:none;overflow:hidden
```

[聊聊 CSS 隐藏元素的 10 种实用方法 - 掘金 (juejin.cn)](https://juejin.cn/post/7210412098810740795#heading-0)

[CSS 隐藏元素的八种方法 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903456545701901#heading-5)

## 5. `display:none` 与 `visibility:hidden`的区别

```sh
共同点：都是让元素隐藏 不可见 都无法被读取
区别：
1. 在渲染树上
   display:none 直接在渲染树上消失，渲染时不占据任何空间
   visibility:hidden 不会消失，继续占据页面空间，只是内容被隐藏
2. 是否继承属性
   display:noen 子元素不会继承该属性，随着父元素一起消失在渲染树上
   visibility:hidden 是继承属性 子元素不可见是因为继承了，修改为visible就可见了
3. 是否造成重排重绘制
   display:none 不占据空间 导致重排有可能导致重绘
   visibility:hidden 占据空间 不可见 导致重绘
```

## 6. 对盒模型的理解

```sh
盒模型：IE盒模型（怪异盒模型） 标准盒模型
属性:box-sizing:   content-box(IE)  border-box(standard)
组成: content(width height) padding margin border
```

```sh
区别:
1. 标准盒模型设置的width和height就是占据页面的宽高 包括了content padding border
2. IE盒模型设置的width和height就是单纯的content内容 实际上的宽高还要大于设置的，包括了content+padding+border

当然 外边距就不包括在里面啦
```

## 7. 单行、多行文本溢出隐藏

+ 单行文本溢出

```css
overflow: hidden;              // 溢出隐藏
text-overflow: ellipsis;       // 溢出用省略号显示
white-space: nowrap;           // 规定段落中的文本不进行换行
```

+ 多行文本溢出

```css
overflow: hidden;
text-overflow: ellipsis;

display: box;
box-orient: vertical;
line-clamp: 3;
```

考虑浏览器的兼容问题，要加前面加上`-webkit-`来兼容一部分浏览器。

```css
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 3;
```



## 8. 两栏布局实现

```sh
左边一栏宽度固定 右边一栏宽度自适应

1. 利用浮动 左侧设置固定宽度并向左浮动 右侧margin-left宽度为auto 占满整个父元素

.left{
	float:left;
	width:200px;
}
.right{
	width:auto;            // 不设置也可填充剩余部分
	margin-left:200px;
}
```

```sh
2. 利用浮动 左侧固定宽度且左浮动 右侧overflow:hidden(触发BFC)
.left{
	width: 200px;
	float: left;
}
.right{
	overflow: hidden;    // 触发块级格式化上下文BFC
	// 具有BFC的元素仍然保持流体特性也就是自动填充除浮动外的剩余空间
	// 不与浮动交集 自动退避浮动元素宽度的距离
}
```

```sh
3. 利用flex布局 父级元素设置弹性布局 左侧固定宽度 右侧元素flex:1
.outer{
	display: flex;
}
.left{
	width: 200px;
}
.right{
	flex: 1
}
```

```sh
4. 使用绝对定位 父级元素设置相对定位 右侧绝对 left right
.outer{
	position: relative;
}
.left{
	width: 200px;
}
.right{
	position: absolute;
	top: 0;
	right: 0;
	left: 200px;
}
```



## 9. 三栏布局实现

```sh
左右两栏宽度固定 中间一栏自适应的布局
1. 左右利用绝对定位 和 中间使用margin
.outer{
	position: relative;
}
.left{
	position: absolute;
	width: 200px;
}
.right{
	positon: absolute;
	right: 0;   // 固定在右侧，此时在下一行
	top: 0;     // 固定与center在同一行
	width: 200px;
}
.center{
	margin: 0 200px;
}
```

```sh
2. 父元素设置弹性盒子布局  中间一栏设置flex为1即可 其中两栏固定宽度
.outer{
	display: flex;
}
.left{
	width: 200px;
}
.right{
	width: 200px;
}
.center{
	flex: 1
}
```

```sh
3. 左右两栏利用浮动，一个向左一个向右 中间使用margin隔开
.left{
	float:left;
}
.right{
	float:right;
}
.center{
	margin: 0 200px;
}
注意：此处的html中center要放在最下面，而不是平时的中间
```

### 双飞翼布局

> 中间`div`外层又包裹了一层`div`，在该子`div`里用`margin-left`和`margin-right`为左右两栏`div`留出位置

```css
.wraper{
    /*包裹在中间一栏外的容器*/
    width: 100%;
    height: 100px;
}
.center{
    margin: 0 200px; /*空出两边的位置*/
    background-color: green;
}
.left{
    width: 200px;
    float: left;
    background-color: gold;
    margin-left: -100%;
}
.right{
    width: 200px;
    float: left;
    background-color: blue;
    margin-left: -200px;
}
```

```html
<div class="outer">
    <div class="wraper">
        <div class="center">
            center
        </div>
    </div>
    <div class="left"></div>
    <div class="right"></div>
</div>
```

### 圣杯布局

```css
body,html{
    padding: 0 200px;
}
.center{
    height: 200px;
    float: left;
}
.right{
    float: left;
    height: 200px;
    margin-left: -200px;
    position: relative;
    right: -200px;
}
.left{
    float:left;
    height: 200px;
    margin-left: -100%;
    position: relative;
    left: -200px;
}
```

```html
<div class="center">center</div>
<div class="left">left</div>
<div class="right">right</div> 
```



# 2023年4月1日 星期六

## 1. 水平垂直居中实现

```sh
1. 利用绝对定位和translate （需要考虑浏览器兼容问题）
.parent{
	position: relative;
}
.child{
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate(-50%,-50%);
	// margin-top: -50px;  height/2
	// margin-left: -50px;  width/2
}

```

```sh
2. 利用绝对定位 设置四个方向都为0 margin为auto （需要盒子有宽高）
.parent{
	position: relative;
}
.child{
	position: absolute;
	top: 0;
	left: 0;
	bottom: 0;
	right: 0;     // 对应方向实现平分
	margin: auto;
}
```

```sh
3. 弹性布局
.parent{
	display: flex;
	justify-content: center;
	align-items: center;
}
```

## 2. 对Flex布局的理解及其使用场景

[彻底理解flex弹性布局，看这一篇就够了！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/393849980)

[面试官：说说flexbox（弹性盒布局模型）,以及适用场景？ | web前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/css/flexbox.html#一、是什么)

```sh
1. 概念
   Flex布局是Flexible box的缩写，意思为弹性布局，用来给盒模型提供最大的灵活性。行内元素也可以使用弹性布局。采用Flex布局的元素，被称为Flex容器，简称容器。所有的子元素自动成为容器成员称为Flex项目。
2. 轴线
   Flex容器默认存在两根轴：水平的主轴以及垂直的交叉轴。项目默认沿着水平主轴排列。可以使用flex-direction来指定主轴的方向。可以使⽤justify-content来指定元素在主轴上的排列⽅式，使⽤align-items来指定元素在交叉轴上的排列⽅式。还可以使⽤flex-wrap来规定当⼀⾏排列不下时的换⾏⽅式。对于容器中的项⽬，可以使⽤order属性来指定项⽬的排列顺序，还可以使⽤flex-grow来指定当排列空间有剩余的时候，项⽬的放⼤⽐例，还可以使⽤flex-shrink来指定当排列空间不⾜时，项⽬的缩⼩⽐例
3. 容器属性
   flex-direction
   flex-wrap
   flex-flow
   *justify-content
   *align-items
   align-contents
4. 项目属性
   order      项目的排列顺序 数值越小越靠前
   flex-grow  定义放大比例
   *flex-shrink  定义缩小比例
   flex-basis    默认auto即本来大小
   *flex      grow|shrink|basis的缩写
   align-self

```

## 3. 为什么需要清除浮动？

```sh
1. html元素在普通流中的排列方式：
   自html中出现的先后顺序自上而下依次排列布局。行内元素水平排列直到当行被占满然后换行，块级元素则会被渲染为一整行
2. 浮动
   浮动使元素脱离文档普通流，漂浮在普通流之上。按照我们设置的浮动方向向左或向右浮动，当浮动元素的高度超出包含框（其实就是父元素）的高度时，父元素自然无法被撑开也不能包裹被浮动元素，即所谓“高度塌陷”
3. 清除浮动的方式
   给⽗级div定义 height 属性
   最后⼀个浮动元素之后添加⼀个空的div标签，并添加 clear:both 样式
   包含浮动元素的⽗级标签添加 overflow:hidden 或者 overflow:auto
   使⽤ :after 伪元素。由于IE6-7不⽀持 :after，使⽤ zoom:1 触发
   .clearfix:after{
   		content:"",
   		display: table;
   		height: 0;
   		clear: both;
   }
   .clearfix{
   		*zoom: 1;
   }
```

```sh
通俗语言：清除浮动是清除浮动带来的负面影响。因为子元素浮动了，脱离了文档的标准流，导致无法撑开 没有设置高度的父元素。此时父元素高度为0，后续的结构直接跑上来占据了父元素所在位置。
```

## 4. 对`BFC`的理解 如何创建`BFC`

```sh
BFC:块级格式化上下文 是web页面中可视化css渲染的一部分，是布局中生成块级盒子的区域 也是浮动元素与其他元素的交互限定区域

通俗: BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定的规则摆放的物品，不会影响到其他容器中的物品。也就是说一个元素符合BFC的条件，则BFC中的元素布局不受外部影响
```

```sh
创建BFC的条件：
1. 根元素 body
2. 设置浮动  float为 left | right 除了none
3. 设置定位  position为 absolute relative
4. overflow hidden | scroll | auto
5. display  flex | inline-block等
```

```sh
特点：
1. 排列方向与普通文档流排列方向一致
2. 在BFC中上下相邻的每个容器的margin会重叠
...
```

```sh
作用：
1. 解决margin的重叠问题。将上下两个盒子变为BFC区域就可以解决重叠
2. 解决高度塌陷的问题:子元素设置浮动之后，父元素会发生高度塌陷，也就是父元素的高度为0。此时只要父元素是BFC，常用overflow
3. 创建自适应两栏布局
   左侧浮动 右侧BFC 这样就不会重叠
```

## 5. `position`的属性有哪些，区别是什么

```sh
属性：
1. absolute 绝对定位  相对static以外的一个父元素进行定位（ position:relative/absolute/fixed）
2. relative 相对定位  相对原来的位置进行定位
3. fixed    绝对定位  相对屏幕视口指定位置，在屏幕滚动时不会改变
4. static   默认      没有定位 元素出现在正常的文档流中
5. inherit  继承父元素position属性
```

## 6. 实现一个三角形

![image-20230401194344283](https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230401194344283.png)

![image-20230401194452900](https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230401194452900.png)

```css
/*令其他三个角的背景都为透明*/
div{
    width:0;
    height:0;
    border-top: 50px solid red;
    border-right: 50px solid transparent;
    border-left: 50px solid transparent;
}
通过控制上下左右边框来控制三角形的方向。
用边框的宽度来控制三角形的角度
```

## 7. 画一条0.5px的线

```css
div{
    width: 200px;
    height: 1px;
    transform: scale(0.5,0.5);
}
```



## 8 JavaScript有哪些数据类型，区别

```sh
1. js的数据类型分为基本数据类型和引用数据类型
   基本数据类型： Number Boolean String Null undefined
   引用数据类型： Function Object Array
   还有Symbol BigInt 是ES6新增的数据类型
   1.1 Symbol:创建后独一无二且不可变的数据类型，为解决全局变量冲突的问题
   1.2 BigInt:数字类型的数据，可以表示任意精度的整数
   
2. 区别：存储位置的不同
   基本数据类型存储在 栈内存 中: 占据空间小 大小固定 使用频繁
   引用数据类型存储在 堆内存 中: 占据空间大 大小不固定 在栈内存中存储了指针，指向堆内存中该实体的起始位置
   
3. 对 堆 和 栈 的概念
   在数据结构中：栈中数据先进后出；堆是优先队列，按照优先级进行排序
   在操作系统中：栈中内存由编译器自动分配释放；堆由开发者进行分配释放，如果没有释放，那么程序结束后由垃圾回收机制回收
```

##  9 数据类型检测的⽅式有哪些

``` sh
1. typeof 
   数组 对象 null 都会被判断为object
2. instanceof 可以正确判断对象的类型，内部运行机制是判断原型链中能否找到该类型的原型
   但是只能判断引用数据类型 不能判断基本数据类型
   可以用来测试一个对象在原型链中是否存在一个构造函数的prototype属性
   
3. contructor
   判断数据的类型  ([]).contructor === Array true 记得加括号
   对象实例通过 constructor 对象访问它的构造函数
   
4. Object.prototype.toString.call() 使用Object的原型方法来判断数据类型
   使用方法：Object.prototype.toString.call([]) 输出[object Array]
```

## 10 判断数组的方式有哪些

```sh
1. 通过 Object.prototype.toString.call() 判断
2. 原型链 arr.__proto__ === Array.prototype
3. ES6的Array.isArray()  
4. instanceof  arr instanceof Array
5. Array.prototype.isPrototypeOf
```

## 11 null和undefined的区别

```sh
1. 首先都是基本数据类型
2. undefined: 未定义 变量声明了但还没有定义会返回undefined
   null:空对象 赋值给一些可能会返回对象的变量作为初始化
3. null的类型会返回 Object   判断 == true | === false
```

# 2023年4月2日 星期天

## 1. `typeof null` 的结果是什么，为什么？

```sh
1. 结果是Object 毫无疑问
2. JavaScript第一个版本中 所有值都存储在32位的单元中 每个单元包含一个小的类型标签以及当前要存储值的真实数据。 类型标签存储在每个单元的低位中。五种数据类型：
   000 object
   001 int
   010 double
   100 string
   110 boolean
3. 有两种特殊数据类型
   undefined 超出整数范围的数字
   null 机器码null指针 （值全是0）
   也就是说null的类型标签也是000 和Object的类型标签一样
```

## 2. `intanceof` 操作符的实现原理及实现

```sh
1. instanceof 用来检测引用数据类型，而无法检测基本数据类型
   arr instanceof Array
   
2. 原理是判断构造函数的prototype属性是否出现在对象的原型链中的任何位置
```

```js
function myInstanceOf(left,right){
    // 获取对象的原型
    let proto = Object.getPrototypeOf(left);
    // 获取构造函数的 prototype对象
    let prototype = right.prototype;
    // 判断构造函数的prototype对象是否在对象的原型上
    while(true){
        if(!proto) return false;
        if(proto === prototype) return true;
        // 如果没有就继续从原型上找
        proto = Object.getPrototypeOf(proto)
    }
    
}
```

## 3. 为什么0.1+0.2 ! == 0.3，如何让其相等

```sh
1. 计算机是通过二进制的方式存储数据的，在计算时实际上是计算的两个数的二进制的和
2. toFixed(num) 可以将Number四舍五入为指定小数位数的数字
3. 设置一个误差范围通常称为机器精度 对JavaScript来说这个值通常为2的-52次方。ES6提供了Number.EPSILON属性就是该值。
   只要判断 0.1+0.2-0.3 < Number.EPSILON 就可判定相等
   Math.abs(arg1 - arg2) < Number.EPSILON;
```

## 4. == 操作符的强制类型转换规则？

```sh
1. 对于 == 比较的双方而言 如果比较的类型不同 就会进行强制类型转换。
   感觉是优先转换为Number和原始类型
   
2. 判断流程
   1. 首先判断类型是否相同 相同就比较两者大小
      1.1 先判断是否为null == undefined 是返回true
      1.2 string == number  将字符串转换为数字类型
      1.3 有boolean比较 就转换为数字
      1.4 object == string | number | symbol 将对象转换为原始
```

## 5. `Object.is()` 与⽐较操作符 “ === ”、“ == ” 的区别？

```sh
1. == 进行比较相等判断时，如果双方类型不同会进行强制类型转换后再对比
2. === 如果类型不同 不会强制 需要类型相同且大小相等才返回true
3. Object.is()在 === 的基础上处理一些特殊情况 如 -0 ≠ +0 NaN === NaN
```

## 6. `new`操作符的实现原理

```sh
1. 首先创建一个空对象
2. 让这个空对象的原型指向函数的prototype
3. 让这个函数的this指向这个对象
4. 判断返回类型 如果是值类型 就返回创建的对象 如果是引用类型 就返回该引用类型
```

```js
function creatNew(){
    let obj = {};
    let [contructor,...args] = [...arguments];
    obj.__proto__ = contructor.prototype;
    let result = constructor.apply(obj,args);
    return typeof result === 'object' ? result : obj;// ?
}
```

## 7. 数组有哪些原⽣⽅法

```sh
字符串操作
1. toString()         [1,2,3].toString() ==> '1,2,3'
2. toLocalString()
3. join()             [1,2,3].join(' ') ==> '1 2 3'

尾部操作
1. pop()              [1,2,3].pop() ==> 3  返回尾部删除的元素
2. push()             [1,2,3].push(8,9)   ==> 5 返回最新长度

首部操作
1. shift()            [1,2,3].shift(1)  ==> 1 返回首部删除的元素
2. unshift()          [1,2,3].unshift(0) ==> 4 返回最新长度
3. reverse()          [1,2,3].reverse()  ==> [3,2,1] 会改变原来数组
4. sort()             [3,2,1].sort() ==> [1,2,3] 会改变原来数组

其他
1. concat() 数组间的拼接             [1,2,3].concat([9,8,7]) ==> [1, 2, 3, 9, 8, 7] 不改变原来数组
2. slice()  截取一部分[start,end]    [1,2,3].slice(0,1) ==> [1] 不改变原来数组 返回被截取部分
3. splice() 截取一部分再添加数据[index,delCount,...addItems]
                                    [1,2,3].splice(0,1,8,9) ==> [1] 改变原数组 返回被截取部分
4. indexOf() 查看元素所在的索引      [8,9,2,3].indexOf(9) ==> 1  从左往右第一个符合的元素
5. lastIndexOf() 从右往左第一个符合的元素
6. every() some() map() forEach()
   every 测试一个数组内的所有元素是否都能通过指定函数的测试。它返回一个布尔值。
   some() 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。
   map() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。
归并
1. reduce()
2. ruduceRight()
```

参考 [Array.prototype.every() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every)

[Array.prototype.map() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map)

[Array.prototype.some() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some)

## 8 什么是 DOM 和 BOM？

```sh
1. DOM 文档对象模型，将文档当做一个对象 主要定义处理网页的方法和接口。dom的顶级对象是document

2. BOM 浏览器对象模型，将浏览器当做一个对象 主要定义与浏览器交互的方法与接口。bom的顶级对象是window

3. dom的顶级对象是bom的顶级对象的子对象
```

## 9 对类数组对象的理解，如何转化为数组

```sh
1. 概念
   拥有length属性和若干索引属性的对象就称为类数组对象，与数组类似 但不能调用数组方法
   常见：arguments和Dom方法的返回结果 函数参数也可以看做类数组对象
2. 方法
   Array.from()
   调用数组的slice splice concat
   Array.prototype.slice.call(arrayLike)
   Array.prototype.splice.call(arrayLike)
   Array.prototype.concat.call(arrayLike)
```

## 10 对`AJAX`的理解，实现⼀个`AJAX`请求

```sh
Ajax指的是通过JavaScript的异步通信 从服务器获取XML文档从中提取数据 再更新当前网页的对应部分 而不用刷新整个网页
```

## 11 JavaScript为什么要进⾏变量提升，它导致了什么问题？

```sh
1. 变量提升：
   无论在函数中何处位置声明的变量 都被提升到了函数的首部，可以在变量声明前访问而不会报错
   
2. 本质原因：js引擎在代码执行前会有一个解析的过程 创建了执行上下文 初始化一些代码执行过程中需要用到的对象。当访问到一个变量时，就去当前执行上下文的作用域链中寻找 而作用域链的首端指的是当前执行上下文的变量对象 这个变量对象是其中一个属性 包含了函数的形参 所有函数以及变量的声明 这个对象在代码解析的时候创建的。

3. 全局上下文：变量定义 函数声明
   函数上下文：变量定义 函数声明 this arguments
   解析和执行：
   3.1 解析时创建一个上下文 把要执行的变量 函数声明都拿出来 变量赋值为undefined 函数先声明
```

```sh
为什么进行变量提升呢？也就是说变量提升的好处
1. 容错性更好！
   如果在声明前使用了也不会报错，只会输出undefined，使一些不规范的代码也能正常运行
2. 提高性能
   JS执行之前 要先进行语法检查和预编译 ==> 避免每次执行前都要解析一遍变量或函数 ==> 提高性能
   解析和预编译过程中的声明提升可以提⾼性能，让函数可以在执⾏时预先为变量分配栈空间
```

```sh
1. 前提：ES6中提出的let const定义变量 就没有变量提升的机制
导致的问题：
   重复声明 函数内容的变量会覆盖掉外部的变量
   循环变量定义的 i 会变量提升为全局变量 函数结束后也不会销毁
```

# 2023年4月3日 星期一

## 1. `let` `const` `var`的区别

```sh
1. let const 存在块级作用域 var没有
   解决了：内层变量可能覆盖外层变量；用来计数的循环变量泄露为全局变量
2. var存在变量提升
3. var声明的变量会自动变为全局变量，并且该变量会被添加全局对象的属性。浏览器中可以使用window.name访问到
4. 重复声明 var允许重复 后声明会覆盖前声明
5. 暂时性死区 在使用let const 声明变量之前 该变量都是不可用的
6. 初始值设置 let var可以不用设置 但是const一定要设置
7. 指针指向 let可以重新赋值 const不可用
```

## 2. 箭头函数与普通函数的区别

```sh
1. 更加简洁
   如果没有参数 直接写空括号
   如果有一个参数 省去括号
   如果有多个参数 括号加逗号隔开
   如果返回值只有一句 可以省略大括号
   不需要返回值 let fn = () => void doesNotReturn(); 调用一个函数 箭头函数本身没有返回值
2. 箭头函数没有自己的this，在作用域的上一层继承this
3. 箭头函数继承来的this指向永远不会改变 call bind apply 都不能改变箭头函数的方向
4. 箭头函数不能作为构造函数使用 即不可以new 因为new会改变函数的指向 但不能
5. 箭头函数没有自己的arguments 访问会得到上一层的arguments
6. 没有prototype
7. 不能用作Generator函数 不能使用yeild
```

## 3. `const`对象的属性可以修改吗

```sh
1. const保证的并不是变量的值不能改动 而是变量指向的那个内存地址不能改动。
2. 如果定义的是基本数据类型 值是不能改动的
3. 如果是引用类型的数据（对象+数组） 变量指向数据的内存地址 保存的只是一个指针 const保证指针不变 但是指向的数据结构怎么 它是不管的
```

## 4.  扩展运算符

```sh
1. 对象扩展运算符 ... 用于取出参数对象中的所有可遍历属性 拷贝到当前对象之中
let bar = { a: 1, b: 2 };
{...bar} === Object.assign({}, bar);
2. Object.assign(target,source) 将source的所有可枚举属性复制到目标对象target上，可以有多个源对象。源对象中同名属性会覆盖掉前面的
```

```sh
1. 数组扩展运算符 ... 可以将一个数组转为用逗号分隔的参数序列 每次只能展开一层
...[1,2,[3,4],5] ==> 1 2  [3, 4] 5
2. 将数组转化为参数序列
add(...numbers) ==> add(1,2) ==> 3
3. 复制数组:可以取出参数对象中的所有可遍历属性 拷贝到当前对象中
arr2 = [...arr1]
4. 数组内合并数组
arr2 = ['one', ...arr1, 'four']
5. 扩展运算符与解构赋值结合 用来生成数组 【扩展运算符只能放在参数最后一位】
const [first, ...rest] = [1,2,3,4,5]
6. 将字符串转为真正的数组
[...'hello']
```

```sh
嵌套解构
const school = {
	classes:{
		stu:{
			name: 'Bob',
			age: 23
		}
	}
}
获取到 name :
const { classes: {stu: { name }}} = school
==> 解构出classes里面的stu里面的name
可以在解构出来的变量名右侧通过冒号+{目标属性名}这种形式进一步解构它 一直解构到拿到目标数据为止
```

## 5. 对`rest`参数的理解

```sh
1. reset【...】运算符可以将分离的参数序列整合成一个数组
   用于获取函数的多余参数 也可以处理函数参数个数不确定的情况
函数声明：
function mutiple(...args){}
mutiple(1,2,3,4)      # 传入的是参数序列 但是args变为数组
```

## 6. ES6的模板语法与字符串处理

```sh
1. 模板语法：拼接字符串 【``】
   1.1 允许使用 ${} 的方式嵌入变量
   1.2 在模板字符串中 空格 缩进 换行都会保留
   1.3 可以在${}中完成计算
   
2. 存在性判定：判断一个字符/串是否在某字符串中;返回布尔值
   2.1 includes 
   2.2 startsWith
   2.3 endsWith
   
3. repeat 使同一个字符串输出多次 连续复制
   arr.repeat(3)
```

## 7 对象与数组解构

```sh
1. 解构是ES6提供的一种新的提取数据的模式 可以针对性地拿到数组或对象中想要的数据
2. 数组解构：以元素的位置为匹配条件
   const [a,,c] = [1,2,3]  ==>  a=1 c=3
3. 对象解构 以属性的名称为匹配条件 来提取需要的数据的
```

# 2023年4月4日 星期二

## 1 对原型和原型链的理解

```sh
1. 在JavaScript中 是使用构造函数来新建对象的。每个构造函数内部都有一个prototype属性 该属性值是一个对象 这个对象包含了所有由该构造函数创建的实例共享的属性和方法。在该实例内部也包含一个指针 指向该构造函数的prototype属性的值 这个指针就被称为原型

注意:  现在浏览器中都实现了 __proto__ 属性来访问这个对象属性，但是最好不要使用 因为它不是规范中规定的。 ES5新增了 Object.getPrototypeOf()方法来获取实例对象的原型 即构造函数的prototype属性
```

```sh
2. 当访问一个对象的属性的时候 当这个对象本身内部并不存在这个属性时 就会去它的原型对象中寻找 也没有就去原型对象的原型中寻找 就一直找下去 就是原型链的概念。

注意：一般原型链的尽头是 Object.prototype 
     JavaScript对象是通过引用来传递的 创建的每个新对象实体中并有属于自己的原型副本 但修改原型时 与之相关的也会继承该改变
```

## 2. 原型链的终点

```sh
原型链上所有原型都是对象。终点是 Object.prototype.__proto__ 是null 所有的对象最终都是有Object构成的
```

## 3. 获取对象非原型链上的属性

```sh
1. 判断是否属于原型链上
   obj.hasOwnProperty(item)
```

```js
function iterate(obj){
    let res = [];
    for(let key in obj){
        if(obj.hasOwnProperty(key)){
            res.push(key+':'+obj[key])
        }
    }
    return res;
}
```

## 4. 对闭包的理解

```sh
1. 闭包是指有权访问另一个函数作用域中变量的函数
2. 创建闭包：在一个函数内创建另一个函数 创建的函数可以访问到当前函数的局部变量
3. 在JS中 闭包存在的意义就是让我们间接访问函数内部的变量
```

```js
function A(){
    let a = 1;
    window.B = function(){
        console.log(a)
    }
}
A()
B()
// 函数B可以访问到函数A中的变量 函数B就是闭包
```

```sh
闭包常用用途：
1. 使我们在函数外部可以访问到函数内部的变量。调用执行B函数，就可以获取到A函数中的私有变量。
2. 使已经运行结束的函数上下文的变量对象继续留在内存中,A函数已经运行完毕 但其中的变量a还被B函数进行引用 闭包函数保留了这个变量对象的引用 不会被回收
```

### 经典面试题：循环中使用闭包解决`var`定义

## 5. 对作用域 作用域链的理解

```sh
1. 全局作用域：最外层函数 最外层函数外面定义的变量 未定义直接赋值的变量 window对象的属性 
   弊端：过多的全局作用域变量会污染全局命名空间 容易引起命名冲突
2. 函数作用域：声明在函数内部的变量 内层作用域可以访问外层作用域

3. 块级作用域：let 和 const 声明 由 { } 包裹的代码片段
              不会有变量提升 也不可以重复声明
              在循环中比较适合绑定块级作用域 声明的计数器可以限制在循环内部
```

```sh
作用域链
1. 在当前作用域中查找所需变量 如果没有这个变量 就去父级作用域中查找 依次向上级作用域查找 直到访问到window对象就终止 这一层层的关系就是作用域链
2. 作用是保证对执行环境有权访问的所有变量和函数的有序访问 通过作用域链 可以访问外层环境的变量和函数
3. 本质上是一个指向变量对象的指针列表 作用域链的前端都是当前执行上下文的变量对象 全局执行上下文的变量对象是作用域链的最后一个对象
```

## 6. 对执行上下文的理解

### 执行上下文

```sh
1. javascript引擎并非一行一行地分析与执行 而是一段一段地分析执行
2. 到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？
   可执行代码包括 全局代码 函数代码 eval代码
   当执行到一个函数时 就会进行准备工作 换个专业说法为 执行上下文
   
注意是：执行一个函数的时候 才会创建一个执行上下文
```

### 执行上下文栈

```sh
1. 一个JavaScript文件中 写的函数多了去 那么怎么管理那么多的执行上下文呢
2. 所以javascript引擎创建了执行上下文栈来管理执行上下文
   初始化的时候 栈底就是 创建的全局执行上下文 是将代码中即将执行的变量 函数声明都拿出来 变量赋值为undefined 函数先声明后使用
   每当遇到一个函数调用 就会创建一个新的执行上下文 引擎会执行栈顶的函数 执行完成之后 才会从栈中弹出 当所有代码都执行完毕之后 才会弹出全局执行上下文
```



# 2023年4月5日 星期三

## 1 异步编程实现方式

```sh
javascript的异步机制：
1. 回调函数
   缺点：多个回调嵌套会导致回调地狱 代码耦合度太高 不利于维护
2. Promise：可以将嵌套的回调作为链式调用
   缺点：有时多个then的链式调用 会造成代码语义不够明确
3. generator：将函数的执行权转移出去 在函数外部再转移出来
   需要考虑何时将函数的控制权转移出来
4. async：是generator和Promise实现的一个自动执行的语法糖
   当函数内部执行一个await语句时 如果返回的是Promise对象 那么函数将会等待Promise对象的状态变为resolve后再往下执行。
   可以将异步逻辑转换为同步的顺序来书写 并且这个函数可以自动执行
```

## 2 `setTimeout promise Async/Await`的区别

```sh
setTimeout是异步任务中的宏任务
```

```sh
promise本身是同步的立即执行函数 当在executor中执行resolve和reject时 此时是异步操作 会先执行then、catch等
```

```sh
async函数需要等待 await 后的函数的执行完成并且有了返回结果之后 才能继续执行下面的代码 await通过返回一个promise对象来实现相同的效果
```



## 3 浏览器的垃圾回收机制

```sh
1. 垃圾回收
   JavaScript代码运行的时候 需要分配内存空间来存储变量和值。当变量不在参与运行时 就会被系统收回被占用的内存空间 就是垃圾回收

回收机制：
    1. JavaScript具有自动回收机制
    2. JavaScript存在两种变量 局部变量和全局变量
       全局变量持续要页面卸载
       局部变量在函数执行结束之后不再使用就会被释放
    3. 当然还有闭包这种情况
       尽管函数执行结束了 函数外部的变量依旧指向函数内部的局部变量 此时局部变量依然再被使用 所以不会回收
       
回收方式
    1. 标记清除：常见的垃圾回收方式
    2. 引用计数
       造成循环引用的问题 两个属性相互引用 引用次数为2 但是函数执行结束之后 引用次数还存在 不会被回收 需要手动进行回收

减少垃圾回收
    当代码比较复杂时 垃圾回收带来的代价就比较大 所以此刻要减少垃圾回收
    1. 对数组进行优化  长度设置为0
    2. 对Object进行优化  设置为null 尽快被回收
    3. 对函数进行优化  可以复用的表达式 尽量放在函数外面
```



## 4 哪些情况会导致内存泄露

```sh
1. 意外的全局变量
2. 被遗忘的计时器或回调函数 
3. 脱离Dom的引用 获取到的Dom元素的引用 后来这个元素被删除了 但这个引用保留着 那就无法被回收
4. 闭包：可能导致某些变量一直被留在内存当中
```

## 5 `GET POST`请求的区别

```sh
1. 幂等：
   一个 HTTP 方法是 幂等 的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。
```

```sh
GET和POST是HTTP请求的两种方法
1. GET请求是幂等的请求 一般用于不会对服务器资源产生影响的场景
   POST请求不是幂等的 一般用于服务器资源产生影响的情景 比如注册
   总之：get一般用于搜索排序和筛选之类的操作 主要是获取资源 读取数据
        post用于修改和写入创建数据

2. GET请求可以将请求的参数放入到URL中向服务器发送 这样的做法相对POST是不太安全的 因为请求的URL会被保留在历史记录中

3. 一般浏览器会对GET请求进行缓存 很少对POST请求进行缓存

4. GET请求的报文中实体部分为空 但POST请求的报文中实体部分多为向浏览器发送的请求参数

 5. GET请求由于浏览器对URL的限制 会被限制发送数据的长度 而且只能发送ASCII字符
   POST请求就能发送的数据更大，也支持更多的数据类型
```

## 6 常见的`HTTP`请求方法

```sh
1. GET: 向服务器获取数据
2. POST: 将实体提交到指定的资源 通常会造成服务器资源的修改 相比PUT可以创建数据
3. PUT: 上传文件 更新数据
4. DELETE: 删除服务器上的对象

5. HEAD: 获取报文首部 与GET相比不返回报文主体内容
6. OPTIONS: 询问支持的请求方法 用来跨域请求
7. CONNECT: 要求在与代理服务器通信时建立隧道 使用隧道进行TCP通信
8. TRACE: 请求服务器回显其收到的请求信息 该方法用于HTTP请求的测试或诊断
9. PATCH: 与PUT相似 用于资源的更新 区别在与部分更新 PUT是总体更新 PUT是幂等的 PATCH不是
```

[HTTP常见请求方法小结 - 掘金 (juejin.cn)](https://juejin.cn/post/7101226255055323167#heading-7)

## 7 `HTTP1.0` 与 `HTTP1.1`之间有哪些区别?

```sh
1. 连接方面：
   1.0采取非持久连接：每次发起HTTP请求都要与服务器建立TCP连接 服务器完成处理之后就会马上断开这个TCP连接
   1.1采取持久连接：可以复用这个TCP连接 以此来避免使用非持久连接时每次需要建立连接的时延
2. 资源请求方面
   1.0中存在带宽浪费的现象 客户端只需要对象中的一部分，但服务器却把整个对象发送过来 并且不支持断点续传
   1.1在请求头引入了range头域 允许只请求资源的一部分
3. 缓存方面
   1.0主要使⽤ header ⾥的 If-Modified-Since、Expires 来做为缓存判断的标准
   1.1则引⼊了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
4. HTTP1.1新增了host字段
5. HTTP1.1还新增了5种请求方法：OPTIONS PUT DELETE TRACE CONNECT
```



## 8 `HTTP1.1`和`HTTP2.0`的区别



## 9 `http`和`https`协议的区别

```sh
1. https需要CA证书 费用较高 http不需要
2. http是超文本传输协议 信息是明文传输的 https则是具有安全性的SSL加密传输协议
3. http协议端口是80 HTTPS协议端口是 443
4. http协议连接很简单 是无状态的 https协议是有ssl和http协议构建的可进行加密传输 身份认证的网络协议 比http更加安全
```

## 10 当键入网址后，到网页显示，其间发生了什么

```sh
1. 解析URL
   URL元素组成：http: + // + web服务器 + 路径
   URL实际上是请求服务器里的文件资源。
   然后根据web服务器和文件名来生成http请求信息
   
2. 缓存判断： 浏览器 ==> 操作系统 ==> hosts文件
   浏览器会先看自身有没有关于这个域名的缓存 如果有 就直接返回 
   如果没有 就去问操作系统 操作系统也查看自己的缓存 如果有 就直接返回 
   如果没有 就去hosts文件看 如果没有 才会去问 本地DNS服务器
   
3. DNS解析
   生成http消息之后 需要委托操作系统将消息发送给web服务器，那么就需要查询服务器域名对应的ip地址 因为委托操作系统发送消息时 必须提供通信对象的ip地址
   DNS服务器专门保存了web服务器域名与IP的对应关系，包括根DNS服务器 顶级域DNS服务器 权威DNS服务器
   
4. 获取MAC地址
5. TCP三次握手
6. HTTPS握手
7. 返回数据
8. 页面渲染
9. TCP四次挥手
```

```sh
域名解析的工作流程（DNS完整的查询过程）
首先：任何DNS服务器都可以找到并访问根域DNS服务器
1. 客户端发出一个DNS请求 发送给本地的DNS服务器
2. 本地域名服务器 先去缓存中找 找不到就去访问根域DNS服务器
3. 根DNS收到本地DNS请求 会返回一个顶级域名服务器的地址
4. 本地DNS收到之后 就去访问顶级域名服务器
5. 顶级域名服务器收到本地DNS请求 会返回一个权威DNS服务器的地址
6. 本地DNS收到之后 就去访问权威域名服务器 会返回一个IP地址
7. 本地DNS收到 就将IP地址返回给客户端 客户端和目标建立连接
```

![域名解析的工作流程](https://gitee.com/zhizhu_wlz/image-for-md/raw/master/6.jpg)

# 2023年4月7日 星期五

## 1 `HTTP`的请求报文和响应报文

```sh
请求报文包括：
1. 请求行：请求方法（POST GET...） url 协议版本（HTTP/1.1）等
2. 请求头部
3. 空行
4. 请求体：POST GET等请求携带的数据
```

```sh
响应报文包括
1. 响应行：网络协议版本（HTTP/1.1）状态码（200 206等）原因短语（OK）
2. 响应头 
3. 空行
4. 响应体：服务器响应的数据
```



## 2 什么是`https`协议

```sh
1. HTTP: 超文本传输协议
2. HTTPS: 超文本传输安全协议：经由HTTP进行通信 利用SSL/TLS来加密数据包 提供对网站服务器的身份认证和保护交换数据的隐私与完整性
在网络层的下面 TCP的上面加入一层安全层 SSL/TLS
安全层的职责：对发起的HTTP请求的数据进行加密操作和对接收到的HTTP内容进行解密操作
```



## 3 `TLS/SSL`的工作原理

```sh
TLS/SSL：安全传输协议 是介于HTTP与TCP之间的一层的安全协议 
         主要依赖三类算法：散列函数hash 对称加密 非对称加密
散列函数：保证完整性
对称加密：信息加密
非对称加密：身份认证 密钥协商
```

```sh
概念：
1. 对称加密：通信双方都使用同一个密钥进行加解密 虽然简单 性能也好 但是无法解决首次发送密钥的时候 容易被拦截
2. 非对称加密：私钥+公钥
   使用私钥进行加密 对应的公钥才能解密 使用公钥解密 对应的私钥才能解密
   通信双方都有一套自己的密钥对 通信之前会发送公钥给对方
   虽然安全性高 但速度慢影响性能
```



## 4 `HTTPS`是怎么保证安全的

```sh
对称加密与非对称加密各有优缺
解决方案：
    结合两种加密方式 将对称加密的密钥使用非对称加密的公钥进行加密 然后发送出去 接收方使用私钥进行解密 得到对称加密的密钥 然后使用对称加密进行沟通
    在这之前 还是要像非对称加密将公钥发给对方的
    为防止被中间人篡改公钥 需要一个安全的CA证书 为了证明身份。证书会包括使用者的公钥 私钥 HASH算法等 以及数字签名（为了得到中间是否被篡改）
```



## 5 常见的`HTTP`状态码

```sh
最常见：
1. 200 ok 表示从客户端发来的请求 在服务器端被正确处理
2. 404 not found 表示在服务器上没有找到请求的资源
3. 400 bad request 请求报文存在错误
4. 403 forbidden
5. 500 服务器端在执行请求时发生了错误
5. 501 服务器不支持当前请求的某个功能
```

## 6 `DNS`协议是什么

```sh
DNS：域名系统 提供主机名到IP的转换服务
     是由分层的DNS服务器组成的分布式数据库 定义了主机如何查询这个分布式数据库的方式的应用层协议 使人更方便的访问互联网 而不用记住IP数组
作用：将域名解析为IP 客户端向DNS服务器发送域名查询请求 DNS告知客户端web服务器的IP地址
```



## 7 `OSI`七层模型

```sh
ISO为了使网络应用更加普及 推出了OSI参考模型
```

![img](https://gitee.com/zhizhu_wlz/image-for-md/raw/master/1604024701811-7ac177bc-d649-45b8-8646-53af8f18a0de.webp)



## 8 `TCP/IP`网络模型

### 各有什么？负责什么？

```sh
1. 应用层: 负责与用户进行交互 我们直接接触到 包括应用软件都是在应用层实现 只需要专注于为用户提供应用功能 把数据传输给传输层 但并不关心数据是如何传输的 
          使用的是HTTP协议 传输的数据包就是消息或报文

2. 传输层: 应用层把数据传给传输层 为应用层提供网络支持 
          有 TCP UDP 传输协议
          TCP比UDP多了很多特性 比如 拥塞控制 超时重传 流量控制等
          但是UDP也有传输效率快 实时性更高的特点 不过它是只负责发送数据包 不保证一定能抵达对方
          在传输层收到应用层的数据如果很大的话 直接传输就不好控制，那么就规定如果数据包的大小超过了MSS即TCP最长报文长度的话 就分块。 好处是如果中途有丢失或者损坏 可以只发送那一个分块 这种分块称为TCP段

3. 网络层: 传输层负责把数据包拿过来 再判断是否切换 那么具体的传输操作它就让给了网络层 它自己就专心服务好应用层
           最常使用的就有IP协议  IP报文 = IP头 + 传输层报文 
           如果IP报文超过了MTU 就会再次进行分片 得到一个即将发送到网络的IP报文

4. 网络接口层：最后一步准备 在IP头部的前面加上MAC头部 封装为数据帧 就可以发送到网络。
       这一步就涉及到以太网了嘛 以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。
       网络接口层为网络层提供链路级别传输的服务 负责在以太网 WIFI这样的底层网络上发送数据包 工作在网卡层次 使用MAC地址标识网络设备
```

### 端口

```sh
   当设备作为接收方 从传输层给到应用层的时候 应用层是有很多应用软件的 那么我们把数据包给谁呢？ 
   需要拿编号来区别这些应用软件 这个就被称为端口
   比如80是web服务器的 22是远程登录服务器的 而浏览器每个标签栏都是一个独立进程 都会分配临时的端口号
```

### IP地址

```sh
网络层负责将数据从一个设备传递给另一个设备 那么设备这么多 怎么找到对方捏？
所以 网络层需要有区别设备的编号 就是IP地址 IP地址 = 网络号 + 主机号
这需要配合子网掩码才能算出 IP 地址 的网络号和主机号
网络号：IP地址 + 子网掩码 进行与运算
主机号：IP地址 + 子网掩码取反 进行与运算
匹配的话 需要匹配到相同的网络号（即同一个子网）才找对应的主机
路由寻址：找到这个子网 然后发送数据包进去
```

### MAC地址

```sh
我们在网络层中判断网络包目的地用的是IP地址 但是在以太网中通讯要用到MAC地址
MAC头部是以太网使用的头部 它包含了接收方和发送方的MAC地址等信息 我们通过ARP协议获取到对方的MAC地址
```

<img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230407232613041.png" alt="image-20230407232613041" style="zoom:67%;" />

<img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230407232632630.png" alt="image-20230407232632630" style="zoom:67%;" />

## 9 `TCP/UDP`

### 概念和特点

**1. 都是传输层协议 都属于TCP/IP协议族**

**2. 都是用来处理数据包**

```sh
UDP：用户数据报协议；不提供数据包分组 组装和不能对数据进行排序 只负责发送数据包
     1. 无连接协议 不需要进行三次握手 只是数据包的搬运工『不会对报文进行拆分和拼接操作』
     
     2. 支持一对一 一对多 多对多的方式
     
     3. 面向报文 因为不拆分只添加一个UDP头部 应用层必须发送合适大小的报文
        发送端：应用层将数据传递给传输层的UDP协议 只会给数据增加一个UDP头 标识是UDP协议 然后就传输给网络层了
		接收端：网络层将数据传递给传输层 UDP只去除IP报文头就传递给应用层 不会拼接操作
     
     4. 不可靠 
        因为无连接 所以不可靠；
        收到什么就传递什么；不会备份；
        也不关心对方是否收到数据包；
        因为恒定速度发送数据 所以网络不好的时候 可能会导致丢包『没有拥塞控制 保持匀速』
     
        但是在某些实时性高的场景 就得使用UDP
     
     5. 头部开销小 传输数据报文高效『不需要像TCP一样需要保证数据不丢失且有序到达』
        只有8KB TCP的至少20字节
        
```

```sh
TCP：传输控制协议 面向连接 可靠的 基于字节流
     1. 面向连接 先进行三次握手 建立可靠连接
     2. 单播传输 一对一 每条TCP传输连接只能有两个端点 进行点对点传输
     3. 面向字节流 不会独立传输 而是不保留报文边界以字节流进行传输
     4. 可靠传输 根据TCP的段编号以及确认号来判断丢包 误码
     5. 拥塞控制 网络出现拥塞时 TCP能减少向网络注入数据的速率和数量
     6. 提供全双工通信 通信双方任何时候都能发送数据 因为TCP的连接都设有缓存 用来临时存放双向通信的数据
```

```sh
UDP头部 
  1. 两位十六位的端口号 分别是源端口『可选』和目标端口

TCP头部
  1. 几个重要的字段：
     Sequence number: 保证TCP传输的报文都是有序的 对端通过序号顺序拼接报文
     Acknowledgement number: 表示数据接收端 期望接收的下一个字节的编号是多少 同时也表示上一个序号的数据已经收到
     window Size: 窗口大小 表示还能接搜多少字节的数据 用于流量控制
  2. 标识符
     URG=1 包含紧急信息
     *ACK=1 确认号字段有效 连接建立后所有报文段都必须置ACK为1
     *SYN=1 与ACK=0搭配 表示当前是一个连接请求报文; 与ACK=1是同意建立连接的应答报文
     *RST=1 表示连接出现问题 可能需要重新建立 也用于拒绝非法报文段和拒绝连接请求
     PSH=1 接收端要立即将数据push给应用层 而不是等缓冲区满后再提交
     *FIN=1 表示释放连接的请求报文
```

### 区别

```sh
1. 是否连接
2. 是否可靠
3. 连接对象个数
4. 传输方式* UDP面向报文 TCP面向字节流
5. 首部开销
6. 使用场景 UDP: 实时应用 例视频会议 直播 TCP: 可靠传输 文件传输
```

### 使用场景

```sh
TCP 效率要求相对较低 但对准确性要求相对高 
    传输中需要对数据进行确认 重发 排序等
    比如 文件传输 远程登录 接受邮件
UDP 效率要求较高 对准确性要求相对低
    QQ聊天 在线视频 网络语音电话 即时通讯 广播通信
```

## 10 TCP三次握手和四次挥手

### TCP头部格式

```sh
1. 序列号『SYN』 建立连接时由计算机生成的随机数作为初始值 通过SYN传给接收端 每发送一次 就累加一次该数据字节流的大小 用来解决网络包乱序问题
```

```sh
2. 确认应答号『ACK』 发送端收到 表明以前的数据都被正常接收 用来解决丢包的问题
```

```sh
3. 控制位
   ACK: 1 ==> 『确认应答』字段有效 最初建立连接的SYN可以不为1
   RST: 1 ==> TCP连接出现异常 必须强制断开连接
   SYN: 1 ==> 希望建立连接 并设定『序列号』初始值
   FIN: 1 ==> 不会再有数据发送 希望断开连接
```



### 三次握手

**IP层是不可靠的 并不保证网络包的交付 不保证按序交付和完整性 要想保证可靠 由上层的TCP协议负责**

**建立一个TCP连接时 需要客户端和服务端总共发送3个包**

**为了确认双方的接收能力和发送能力是否正常 指定初始化序列号为后面的可靠性传送做准备**

```sh
1. 客户端==>服务端 发送一个SYN报文（不能携带数据） 并指明初始化序列号（client_isn）
   同步位 SYN=1 初始序列号 seq=client_isn
   
2. 服务端==>客户端 应答自己的SYN报文 指定初始化序列号（server_isn） 指定ACK为初始序列+1
   同步位 SYN=1 初始序列号 seq=server_isn 确认序列号 ack=client_isn+1
   
   客户端收到之后 确认了第一次握手中自己的发送能力和服务端的接收能力
   
3. 客户端==>服务端 发送一个ACK报文 （可以携带数据）
   同步位 ACK=1 确认号 ack=server_isn+1 初始序列号seq=client_isn+1『因为是第二个报文段』 
```

<img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230408135336996.png" alt="image-20230408135336996" style="zoom:80%;" />

### 为什么是三次握手？

```sh
之前学习的时候 确实觉得只有三次握手才能保证双方具有接收和发送的能力 
    在客户端第一次接收到服务器端的消息时 可以确保客户端的发送能力和服务端的接收能力 
    服务端第二次收到消息的时候 可以确保自己的发送能力和客户端的接收能力
```

```sh
后来看博客的时候 还学习到一个比较重要的点：也就是三次握手的首要原因
   三次握手可以阻止重复历史连接的初始化 防止旧的重复连接初始化造成混乱
   比如客户端连续发送多次SYN建立连接的报文 在网络拥堵的情况下：
   一个旧的报文『seq=90』比最新的SYN报文『seq=100』早到达了服务端 那么服务端回一个ACk报文『确认号91』
   但是客户端希望收到的是『确认号为101』的ACK报文 于是回RST报文
   服务端收到RST报文后 就会释放连接
   后续最新的SYN到达了服务端 就可以正常完成三次握手了
```

『 旧`SYN`报文 』称为历史连接 。`TCP`三次握手建立连接的最主要原因就是防止『 历史连接 』初始化了连接。

```sh
如果是两次握手 就无法阻止了：服务端没有中间状态给客户端来阻止历史连接 导致服务端可能建立一个历史连接 造成资源浪费
二次握手：服务端收到SYN报文后 就进入ESTABLISTEN状态 可以发送数据了 
         但是客户端判断到此处为历史连接就发RST报文断开连接 
         如果服务端在向客户端发送数据前 没有阻止掉历史连接 导致服务端建立了历史连接 又白白发送了数据 浪费了服务端的资源
```

```sh
原因2：同步双方初始序列号

原因3：避免资源浪费 由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文，所以服务端每收到一个 SYN 就只能先主动建立一个连接
      如果客户端发送的 SYN 报文在网络中阻塞了，重复发送多次 SYN 报文，那么服务端在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。
```

### 四次挥手

**TCP断开连接是通过四次挥手方式**

**双方都可以主动断开连接 断开连接后主机的资源将被释放**

```sh
客户端主动关闭连接 —— tcp四次挥手
1. 客户端==>服务端 发送断开连接的FIN报文 不再发送数据 但还可以接收数据
2. 服务端==>客户端 收到后发送ACK应答报文 可能还有数据需要处理和发送
3. 服务端==>客户端 服务端处理完数据之后不再发送了 才发送FIN报文 表示同意现在关闭连接
4. 客户端==>服务端 收到后发送ACK应答报文
可以看到每个方向都需要一个FIN和一个ACK 因此为四次挥手 服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，因此是需要四次挥手。
```

![image-20230408155359254](https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230408155359254.png)

## 11 `keep-alive`的理解

```sh
概念：是使客户端和服务器端的连接持续有效 当出现对服务器的后续请求时 keep-alive避免建立或重新建立连接 就是长连接

http1.0 默认是短连接 每次请求和应答 要建立连接 完成后马上断开 需要发送collection字段
http1.1 默认保持长连接
```

```sh
建立过程：
1. 客户端==>服务端 发送请求报文同时添加Connection字段
2. 服务端==>客户端 收到并处理字段 回送Connection:Keep-alive
3. 客户端收到Connectionz字段 连接建立成功
```

```sh
优点：
1. 较少CPU和内存使用『同时打开的连接减少了』
2. 减少了后续请求的延迟『不需要每次都建立连接』
3. 减低拥塞控制『TCP的连接减少了』
缺点：
长时间的TCP连接容易导致系统资源无效占用 浪费系统资源
```



# 2023年4月10日 星期一

## 1 Vue的基本原理

```sh
vue最深刻的两个特点 肯定就是响应式编程（双向数据绑定） 组件化嘛
优势是：轻量 双向数据绑定 组件化 数据和结构分离 虚拟DOM 运行速度快
```

```sh
当一个Vue实例创建时 Vue会遍历到data中的属性 用Object.defineProperty将它们转换为getter/setter 并且在内部追踪相关依赖 在属性被访问和修改时通知变化，每个组件实例都有相应的Watcher程序实例 它会在组件渲染的过程中把属性记录为依赖 之后当依赖项的setter被调用时 会通知Watcher重新计算 从而使关联的组件得以更新。
```

```sh
vue是一个MVVM渐进式框架 MVVM是Vue设计模式 在Vue框架中数据会自动驱动视图
1. MVVM设计模式
   Model：数据模型 就是Vue组件中的data或者Vuex中的数据
   View：视图 就是DOM 对应html部分即UI组件 负责将数据模型展示出来
   ViewModel：监听模型数据即data 改变或控制视图行为 处理用户交互等
   Model和View没有直接联系 而是通过ViewModel进行交互 之间交互是双向的。ViewModel通过双向数据绑定将View和Model连接起来 之间的同步工作不需要开发者干涉 不需要手动操作DOM 只需要关注业务逻辑即可
   
2. 响应式：View和Model之间的同步工作
   Vue在创建实例的时候 遍历data中的属性 通过ES5的Object.defineProperty 将它们转化为getter/setter 在属性上添加访问器属性 当读取到data中的数据会自动调用get方法 修改时会自动调用set方法 检测到数据的变化 会通知观察者Watcher 然后自动触发重新render组件 生成新的虚拟DOM对象 对比后局部修改到真实DOM树上 
```

[面试官: 你对虚拟DOM原理的理解? - 掘金 (juejin.cn)](https://juejin.cn/post/6844903902429577229)

## 2. `Computed` 和 `Watch` 的区别

```sh
Computed: 
   1. 支持缓存 只有依赖的数据发生了变化 才会重新计算
   2. 不支持异步 当computed有异步操作时 无法监听数据的变化
   3. 基于响应式依赖进行缓存，即data或者props
   4. 如果属性是函数则默认使用get方法 可以有set和get方法
Watch:
   1. 不支持缓存 数据变化时 就触发相应的操作
   2. 支持异步监听
   3. 函数支持两个参数 一个是新值 一个是旧值
   4. 监听的数据必须是data中声明的或者props数据，函数有两个参数：
      immediate: 组件加载时立即触发回调函数
      deep:深度监听 可以监听到数组中的对象发生变化 但是无法监听到数组和对象内部的变化
   当想要执行异步或者昂贵的操作以响应不断的变化 就使用Watch
```

```sh
Computed有缓存 根据依赖的属性值发生改变 才会重新计算 如果没变 就直接从缓存拿数据了
Watch没有缓存 是监听 类似数据的监听回调 每当监听的数据发生变化就会执行回调进行后续的操作
```

## 3. `v-if`和`v-show`的区别

```sh
1. v-if是动态添加或删除DOM元素 v-show是设置DOM元素的display样式
2. v-if切换有局部编译和卸载的过程 v-show只是单纯地基于css
3. v-if惰性编译 只有第一次为真才开始编译 v-show是无论什么都会编译 缓存 保留DOM元素
4. v-if有更高的切换消耗 v-show有更高的初始渲染消耗
5. v-if适合条件不怎么改变的 v-show适合频繁切换
```



## 4. `data`为什么是函数而不是对象

```sh
Vue组件可能会存在多个实例 如果采用对象形式定义data 则会导致公用一个data对象 那么状态变更将会影响所有组件实例 
但是使用函数形式定义 在initData时则会作为工厂函数返回全新data对象 有效规避多实例之间状态污染问题
```

## 5 Vue 单⻚应⽤与多⻚应⽤的区别

```sh
SPA单页面应用指的是只有一个主页面的应用 一开始只需要加载一次js css资源 相关的内容都包含在主页面里面 对每个功能模块化组件化 单页应用跳转 就是切换相关组件 刷新局部资源
MPA多页面应用指的是有多个独立页面的应用 每个页面必须重复加载js css资源 多页应用跳转 需要整页资源刷新
```

## 5. Vue的优点

```sh
1. 轻量级框架：只关注视图层
2. 双向数据绑定
3. 组件化
4. 数据 视图 结构分离
5. 虚拟DOM：dom操作时非常耗费性能的
6. 运行速度更快 
```

## 6. 对 SPA 单⻚⾯的理解，它的优缺点分别是什么？

```sh
SPA: 仅在web页面初始化的时候加载相应的js css html。一旦页面加载完成 SPA就因为用户的操作而进行页面的重新加载或跳转；而是利用html内容的变化 UI与用户的交互 避免页面的重新加载。
```

```sh
优点：
   1. 用户体验好 避免不必要的跳转和重复渲染，不需要重新加载整个页面
   2. SPA就相对服务器压力小
   3. 前后端分离 前端进行交互逻辑 后端负责数据处理

缺点：
   1. 初次加载耗时多 为了实现单页面应用和显示效果 需要在加载页面的时候将JavaScript css统一加载 部分页面要按需加载
   2. 前进后退路由管理，浏览器不会自动记录 所有的页面切换需要自己建立堆栈管理vue-router
   3. SEO难度较大
```



## 7. 说一下生命周期

```sh
从开始创建 初始化数据 编译模板 挂载DOM ==> 渲染 更新 ==> 渲染 卸载等一系列过程 称为Vue的生命周期
流程线：beforeCreate『创建前』 ==> created『创建后』 ==> beforeMount『挂载前』 ==> mounted『挂载后』 ==> 
       beforeUpdate『更新前』 ==> updated『更新后』 ==> beforeDestory『销毁前』 ==> destoryed『销毁后』
生命周期函数中的this指向是vm或组件实例对象
```

```sh
1. beforeCreate: 初始化事件和数据监测还没开始 什么都访问不到。已经初始化了 但是还没有数据监测和数据代理
   created: 实例创建完成 实际上配置的data computed watch methods等都已经完成 但是此刻渲染的节点还未挂载到DOM上 还不能访问到$el，已经完成数据监测和数据代理

2. beforeMount: 在挂载前渲染 编译模板 生成html 此刻还没有被挂载html到页面上。 已经编译模板 生成了虚拟DOM
   mounted: vue完成模板的解析并把初始的真实DOM放入到页面后就调用mounted。页面上已经是经过编译后的DOM页面 可以进行DOM的操作。在这个阶段可以进行开启定时器啊 发送网络请求 绑定自定义事件 订阅事件之类
   
3. beforeUpdate: 此时是新数据 但旧页面
   updated: 数据与页面同步
   
4. beforeDestoryed: 此时的DOM还是可用的还可以访问到 进入准备销毁阶段 可以开始关闭定时器 取消订阅之类 解绑自定义事件的操作 一般在这个阶段不会操作数据了 即便操作也不会触发更新流程了
   destoryed: 销毁Vue实例
```



## 8.  组件通信的方式

```sh
1. props $emit
   父组件向子组件传值 通过props
   子组件向父组件传值 通过$emit 绑定一个自定义事件 当这个事件被执行的时候就会将参数传递给父组件 而父组件通过v-on监听并接收参数
```

```js
// 子组件中声明的函数
handleClick(index){
    this.$emit('onEmitIndex',index); // 触发父组件的方法 传递参数index
}
```

```vue
// 父组件中对子组件的引用
<son @onEmitIndex="handleEmit"><son/>
    
handleEmit(index){
    this.index = index;  // 这个index就是子组件传过来的
}
```

```sh
2. eventBus事件总线 $emit $on
   创建事件中心管理组件之间的通信 export const EventBus = new Vue();然后在组件中进行引入.
```

```js
// 组件：发送事件
EventBus.$emit('addition',{
   num: this.num++
})
```

```sh
// 接收事件
EventBus.$on('addition', param => {
	console.log(param)
})
```

```sh
3. vue依赖注入 用于层数比较深的父子或祖孙这类的组件来传值 就不需要一层一层进行传递
   provide/inject 是vue提供的钩子和data是同级的
   provide: 钩子用来发送数据或方法
   inject: 用来接收数据和方法
   但是依赖注入所提供的属性是非响应式的
```

```js
// 父组件 provide和data书写形式一致
provide(){
    retutn{
        num: this.num;  // 只传递num
        app: this       // 这样就可以访问父组件的所有属性了
    }
}
```

```js
// 子组件
inject: ['num']
```

```sh
4. ref或$refs 用于实现父子组件之间的通信
   ref用于子组件上 引用指向了子组件的实例 可以通过实例来访问
```

```js
// 在父组件中声明子组件
<Child ref="child" />
    
mounted(){
    console.log(this.$refs.child)  // 这样就可以访问到child组件的所有方法和属性了  
}
```

```sh
5. $parent/$children 
   使用$parent 可以让组件访问父组件的实例 访问的是上一级父组件
   使用$children 可以让组件访问子组件的实力 但不能保证顺序 拿到的是所有子组件的实例 是一个数组并无序
   可以通过$root访问到根组件的实例
   $children 的值是数组，⽽ $parent 是个对象
```

```sh
6. $attrs/$listeners: 实现组件之间的跨代通信 直系祖孙传递数据
```



## 9.  路由的`hash`和`history`模式的区别

```sh
vue-router默认模式就是hash模式
1. hash模式的URL带着一个 # 
   只会出现在URL里面 但不会出现在HTTP请求中 对后端没有影响
   兼容性很好 低版本IE也支持 hash路由被称为前端路由
   原理：onhashchange()事件：在页面的hash值发生变化 无需向后端发起请求 window可以监听事件改变 按规则加载相应的代码 另外hash值对应的URL都会被浏览器记录下来 实现页面的前进和后退
   
2. history模式没有 # 使用的是传统的路由分发模式 用户输入一个URL 服务器会接收这个请求 并解析URL 做出相应的逻辑处理
   相对hash模式更加好看 但需要后台配置 不然会返回404
   有两部分history API：切换后台状态和修改历史状态
   pushState() replaceState() forward() back() go()
   缺点：在刷新的时候 没有相应的路由或资源 会刷出404
```

## 10 定义动态路由和获取路由参数

```sh
1. param方式：需要提前在声明时进行占位
   格式：/router/:id/:title  到时使用的时候直接进行传值即可
   注意：如果是对象写法 只能和name搭配使用
   参数获取的时候: $route.params.id $route.params.title
   
2. query方式：在路径参数会出现?号
   声明的时候就是普通配置 不需要其他
   格式：使用query的key作为传递  形成的路径信息：/router?id=123 可以和name或者path搭配的ok
   参数获取：$route.query 获取传递的值
```

```html
// 示例 params
// 1. 直接在router-link中使用
<router-link :to="'/router/'+id+'/'+title"></router-link>
```

```js
// 2. 使用跳转方法进行
this.$router.push({ name:'user', params:{id, title} })
this.$router.push('router'+id+'/'+title);
```

```html
// 实例 query 
// 1. path+query搭配
<router-link :to="{
       path: '/router',
       query: {id:123, title:'hello'}
}"></router-link>
// 2. name+query搭配
<router-link :to="{
       name: 'Category',
       query: {id:123, title:'hello'}
}"></router-link>
```

```js
// 使用跳转方法
// 3. name/path+query
this.$router.push({ name:'user', query:{id, title} })
this.$router.push({ path:'/user', query:{id, title} })
// 4. 路径形式
this.$router.push('/router?id='+id);
```

```sh
params和query的区别：
1. query可以用path或者name来引入 但params只能使用name来引入
2. 接收参数的方式都是类似的 this.$route.query.id this.$route.params.id
3. query携带?号 类似get传参 params类似post
   query会在浏览器中显示url参数 后者则不显示
4. query刷新不会丢失query里面的数据 params会丢失
```

## 11. 对前端路由的理解

```sh
1. 前端早期 一个URL对应一个页面 页面的切换必然伴随页面的刷新 也是因为只有页面刷新才可以重新去请求数据
2. 后来出现Ajax 可以在不刷新页面的情况下进行数据请求 更新页面内容 之后就出现了SPA单页面应用
3. SPA极大提升了用户体验 允许在不刷新的情况下更新页面内容 使内容的切换更加流畅。但一开始时并没有定位这一说 内容切换前后的URL是一致的 也不会保留你当前的进展 一刷新就回到最初的起点 且只有一个URL给页面做映射 对SEO也不够友好
4. 为解决 前端路由出现 帮助我们在仅有一个页面的情况下 记住用户当前的操作 为每一个视图都匹配唯一标识来判断当前的位置 为了刷新之后内容也不归零
5. 思路是这样的：
   1. 拦截用户的刷新操作 
   2. 感知URL的变化 在前端对URL做一个微小的处理 不影响本身的性质和服务器对它的识别 一旦感知到了这个变化 就用js来生成不同的内容
```



# 2023年4月17日 星期一

## 1. `Promise`的理解

```sh
1. Promise 对象是异步编程的⼀种解决⽅案，最早由社区提出。

2. Promise 是⼀个构造函数，接收⼀个函数作为参数，返回⼀个 Promise 实例。⼀个 Promise 实例有三种状态，分别是pending、resolved 和rejected，分别代表了进⾏中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态⼀经改变，就凝固了，⽆法再被改变了。

3. 状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调⽤这两个函数改变Promise 实例的状态，它的原型上定义了⼀个 then ⽅法，使⽤这个 then ⽅法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执⾏。

注意：在构造 Promise 的时候，构造函数内部的代码是⽴即执⾏的
```

 ```js
 let promise = new Promise(function(resolve,reject){
     // some code
     if(condition){
         resolve();
     }else{
         reject();
     }
 });  // 返回的promise对象 还可以调用then方法
 // then ⽅法可以接受两个回调函数作为参数。第⼀个回调函数是Promise对象的状态变为 resolved 时调⽤，第⼆个回调函数是Promise对象的状态变为 rejected 时调⽤。
 ```

## 2. 对`async/await`的理解

```sh
1. async/await是Generator的语法糖 它实现的效果都能通过then来实现 是为了优化then链开发出来的

2. 从字⾯上来看，async是“异步”的简写，await则为等待，所以很好理解async ⽤于申明⼀个 function 是异步的，⽽ await ⽤于等待⼀个异步⽅法执⾏完成。当然语法上强制规定await只能出现在asnyc函数中。

3. async 函数返回的是⼀个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回⼀个 Promise 对象，如果在函数中 return ⼀个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。async 函数返回的是⼀个 Promise 对象，所以在最外层不能⽤ await 获取其返回值的情况下，当然应该⽤原来的⽅式： then() 链来处理这个 Promise 对象
```

```sh
await在等待什么？

1. await 表达式的运算结果取决于它等的是什么。
   如果它等到的不是⼀个 Promise 对象，那 await 表达式的运算结果就是它等到的东⻄。
   如果它等到的是⼀个 Promise 对象，await 就忙起来了，它会阻塞后⾯的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。
   
2. 单⼀的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在⼜⽤ async/await 来进⼀步优化它）。
```

 <img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230418001134652.png" alt="image-20230418001134652" style="zoom:80%;" />

```sh
async/await对⽐Promise的优势

1. 代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担
2. Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅
3. 错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余
4. 调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。
```



# 2023年4月18日 星期二

## 1. 事件代理

**DOM事件三大阶段：捕获-目标-冒泡**。

### 1.1 事件委托

利用 [JS 事件冒泡](http://c.biancheng.net/view/9379.html)动态为元素绑定事件的方法称为**事件委托**（Event Delegation，也称为“事件代理”），是 JavaScript 中最热门的技术之一。

要使用事件委托，需要保证事件能够发生冒泡，适合使用事件委托的事件有  `click`、`mousedown`、`mouseup`、`keydown`、`keyup`、keypress 等。

需要注意的是，虽然 `mouseover `和  `mouseout `事件也会发生事件冒泡，但处理起来非常麻烦，所以**不推荐**在 `mouseover `和 `mouseout `事件中使用事件委托。

 另外，对于不会发生事件冒泡的事件（例如 load、unload、abort、focus、blur 等），则无法使用事件委托。

### 1.2 事件冒泡

 ![](http://c.biancheng.net/uploads/allimg/210927/09441W5b-0.gif)

1. 在事件捕获阶段，事件会从 DOM 树的最外层开始，依次经过目标节点的各个父节点，并触发父节点上的事件，直至到达事件的目标节点。
2. 事件冒泡正好与事件捕获相反，事件冒泡是从目标节点开始，沿父节点依次向上，并触发父节点上的事件，直至文档根节点。

#### 1.2.1 阻止事件捕获和冒泡

```js
event.stopPropagation(); // 会阻止事件捕获和事件冒泡，但是无法阻止标签的默认行为，如链接。
```

```js
event.preventDefault(); // 阻止一些默认行为。如链接和提交按钮。
```

## 2. 事件循环

### 2.1 大前提：

首先，`JavaScript`是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，**而实现单线程非阻塞的方法就是事件循环**。

### 2.2 分类

在`JavaScript`中，所有的任务都可以分为

- 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行
- 异步任务：异步执行的任务，比如`ajax`网络请求，`setTimeout`定时函数等。

 <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/21/15fdd88994142347~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" style="zoom: 50%;" />

导图要表达的内容用文字来表述的话：

- 同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入Event Table并注册函数。
- 当指定的事情完成时，Event Table会将这个函数移入Event Queue。
- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。
- 上述过程会不断重复，也就是常说的Event Loop(事件循环)。

[事件循环参考掘金博客](https://juejin.cn/post/6844903512845860872)

 <img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/15fdcea13361a1ec~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img" style="zoom: 50%;" />

- **``javascript``是一门单线程语言**
- **Event Loop是`javascript`的执行机制**

## 3. 垃圾回收机制

### 3.1 前提

因为**内存泄漏**了，所以引擎才会去回收这些没有用的变量，这一过程就叫垃圾回收。

程序的运行需要占用内存，**当这些程序没有用到时，还不释放内存，就会引起内存泄漏。**不再用到的内存，没有及时释放，就被称为内存泄漏。内存泄漏，会让系统占用极高的内存，让系统变卡甚至奔溃。

导致这问题的原因是 JavaScript 的引擎 V8 只能使用一部分内存，具体来说，在 64 位系统下，V8 最多只能分配 1.4G；在 32 位系统中，最多只能分配 0.7G。

因为使用内存大小上限，所以当有用不到的变量时，引擎会帮我们清理掉。

### 3.2 回收

**回收内存。清理变量，释放内存空间**  

参考链接：[深入理解垃圾回收机制](https://zhuanlan.zhihu.com/p/576722965)

### 3.3 机制

基本类型存在栈内存，引用类型存在堆内存。

**引擎需要栈来维护程序执行时的上下文状态**，如果所有数据都存放在栈内存中，会影响到上下文切换的效率，从而影响整个程序的执行效率。所以内容大的被存放到堆内存中。

 <img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230317164756336.png" alt="image-20230317164756336" style="zoom:80%;" />

 <img src="https://gitee.com/zhizhu_wlz/image-for-md/raw/master/v2-ba1ae480cc0a1382e0b607ba92cabe75_r.jpg" style="zoom:67%;" />

![img](https://gitee.com/zhizhu_wlz/image-for-md/raw/master/v2-33f352d7ded14073b6fbf83a8b90dad5_r.jpg)

- Scavenge 算法：将空间分为两半，一半是 from 空间，一半是 to 空间。新加入的对象会放在 from 空间，当空间快满时，执行垃圾清理；再角色调换，再当调换完后的 from 空间快蛮时，再执行垃圾清理，如此反复

- 标记-清理-整理：此为两个算法，「标记-清理」算法和 「标记-整理」算法 

- - 标记-清理：标记用不到的变量，清理掉
  - 标记-整理：清理完内存后，会产生不连续的内存空间，为节省空间，整理算法会将内存排序到一处空间，空间就变大了

### 3.4 引用计数

引擎会有张”引用表“，保存了内存里面的资源的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。将`arr`置为`null`即可

出现问题：数组`[1,2,3,4]`是一个值，会占用内存。但被`arr`引用了。因此引用次数为1，但接下来的代码却没有用到`arr`，因此还是会持续占用内存。

```js
const arr = [1, 2, 3, 4];
console.log('hello world');
```

只要外部的引用消失，`WeakMap `内部的引用，就会自动被垃圾回收清除。



### 3.5 哪些操作

#### **几种造成内存泄漏的情况：**

1. 意外声明全局变量。不使用`var`声明的变量，相当于挂载到`window`上。这样子只要window对象没有被清理，那么它的属性就一直存在，造成内存泄漏。

   **解决方法：**加上声明关键字；使用`this`关键字；严格模式；赋值为`null`

2. 定时器导致的泄露。`setInterval(()=>{},100)`

3. 闭包：只要返回的函数存在就不能清理 `name`

   ```js
   let fn = functuon(){
       let name = "mary";
       return function(){
           return name;
       }
   }
   ```

4. 没有清理的`DOM`元素引用

#### **减少垃圾回收**

**前提：**尽管浏览器可以进行垃圾自动回收 但是当代码比较复杂的时候 垃圾回收带来的 代价比较大 所以应该减少垃圾回收

```sh
1. 对数组进行优化：最简单的就是赋值为[] 但这种情况会创建一个新对象出来 最好将数组的长度设置为0 以此达到清空数组的目的
2. 对object进行优化：对象尽量复用 设置为null
3，对函数进行优化：如果可以复用在函数中的的函数表达式，尽量放在函数外面
```



## 4. Vuex的原理

```sh
vuex是专门为vue.js开发的状态管理模式 每个vuex一样的核心就是store『仓库』可以看做是一个容器 包含你的应用中的大部分的状态『state』
1. Vuex的状态存储是响应式的 store的状态发生变化 相应使用该状态的组件也会得到更新
2. 改变state的唯一途径只有显式提交『commit』 mutation
3. 组件触发『dispatch』异步事件或动作actions actions再将这个动作提交给mutations 然后再去改变state的状态 改变之后就会重新渲染到组件中 展示更新后的新数据
```

```sh
各个模块：
1. Vue Components：Vue组件 html页面负责接收用户操作等交互 执行dispatch触发对应的action来进行回应
2. dispatch：操作行为触发方法 是唯一能执行action的方法
3. actions：操作行为处理模块 负责处理所有接收到的交互行为 包括同步异步操作 支持多个同名方法 按照注册的顺序依次触发
   可以在里面请求后台API 触发其他action 以及提交mutation的操作
   提供了promise的封装 以及action的链式触发
4. commit：状态改变提交操作方法 对mutation进行提交 是唯一能够执行mutation的方法
5. mutations：状态改变操作方法 是Vuex修改state的唯一推荐方法 方法名全局唯一
6. state：页面状态管理容器对象 集中存储vue components中data对象的零散数据 全局唯一 以进行统一的状态管理
7. getters：state对象读取方法
```

```sh
Vuex 实现了⼀个单向数据流，在全局拥有⼀个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调⽤获取 State 数据的更新。⽽当所有异步操作(常⻅于调⽤后端接⼝异步获取更新数据)或批量的同步操作需要⾛ Action ，但 Action 也是⽆法直接修改 State 的，还是需要通过Mutation 来修改State的数据。最后，根据State 的变化，渲染到视图上。
```

## 5. `Vuex`中`action`和`mutation`的区别

```sh
1. mutation中的操作是一系列的同步函数 用于修改state中的变量的状态。要使用Vuex时需要通过commit来提交需要操作的内容。接收第一个参数是state
2. action的不同点在于：
   action中可以包含任意异步操作
   不可以直接修改state中的变量的状态 需要提交mutation 由mutation来更改state变量状态
   接收一个与store实例具有相同属性和方法是context对象 所以可以调用commit方法来提交 或者通过context.state等进行访问
```

```js
// 使用
const store = new Vuex.store({
    state:{
        count: 0;
    },
    mutations:{
        increment(state){
            state.count++;
        }
    },
    actions:{
        increment(context){
            context.commit('increment');
        }
    }
})
```

```sh
1. mutation专注于修改state变量的状态 action主要负责的是业务代码 异步请求，不能直接操作state
2. mutation必须同步执行 action可以异步
3. 视图更新的时候 先触发action action再触发mutation
4. 参数 mutation的参数是state 包含store中的数据 
       action的参数是context 包含store getters等
```

## 6. `Redux` 和 `Vuex` 有什么区别，它们的共同思想

#### `Redux `和 `Vuex`区别

1. `Vuex`改进了`Redux`中的`Action`和`Reducer`函数，以`mutations`变化函数取代`Reducer`，⽆需`switch`，只需在对应的`mutation`函数⾥改变`state`值即可

2. `Vuex`由于`Vue`⾃动重新渲染的特性，⽆需订阅重新渲染函数，只要⽣成新的`State`即可

3. `Vuex`数据流的顺序是∶`View`调⽤`store.commit`提交对应的请求到`Store`中对应的`mutation`函数==>`store`改变（`vue`检测到数据变化⾃动渲染）

> 通俗点理解就是，`vuex `弱化 `dispatch`，通过`commit`进⾏ `store`状态的⼀次更变;
>
> ​                              取消了`action`概念，不必传⼊特定的 `action`形式进⾏指定变更;
>
> ​                              弱化`reducer`，基于`commit`参数直接对数据进⾏转变，使得框架更加简易;

#### 共同思想

1. **单—的数据源**

2. **变化可以预测**

本质上：`redux`与`vuex`都是对`mvvm`思想的服务，将数据从视图中抽离的⼀种⽅案;

形式上：`vuex`借鉴了`redux`，将`store`作为全局的数据中⼼，进⾏`mode`管理;

## 7. `Vue3.0`有什么更新

```sh
1. 监测机制的改变：
   消除了Vue2中基于Object.defineProperty的实现所存在的限制 带来了基于代理Proxy的observer实现
   
2. 只能监测属性 不能监测对象
   监测属性的添加和删除 数组索引和长度的变更 支持 Map Set和弱引用
   
3. 插槽
   vue2.x的机制导致作用域插槽改变就会使父组件重新渲染
   vue3.0将作用域插槽改为函数的形式 只会重新渲染子组件 提高性能

4. render函数
   vue3.0进行更改使用api生成vdom
```

## 8. `defineProperty`和`proxy`的区别

```sh
Vue2中在实例初始化的时候会遍历data中的所有属性 并使用Object.defineProperty把这些属性都转为setter getter 这样当追踪数据发生变化的时候 setter会被自动调用 Object.defineProperty是ES5的一个特性

出现的问题：
1. 添加或删除对象的属性的时候 vue2是检测不到的 因为这个新操作没有在初始化的时候添加到响应式处理上
2. 无法监控到数组下标和长度的变化
```

```sh
Vue3使用proxy来监控数据的变化 Proxy是ES6提供的功能 是为了定义基本操作的自定义行为『属性查找 赋值 枚举 函数调用等』

相对于Object.defineProperty的特点：
1. Proxy可以直接代理整个对象而非对象的属性 这样就可以只需一层代理就可以监听同级结构下的 所有属性变化包括新增属性和删除的属性
2. Proxy也可以监听数组的变化
```

## 9 虚拟`DOM`的理解

```sh
1. 本质上来说 虚拟DOM是DOM的抽象 是一个JavaScript对象 通过对象的方式来表示DOM结构 是更加轻量级的对DOM的描述

2. 好处：
   将页面的状态抽象为JS对象的形式 配合不同的渲染工具 使跨平台渲染成为可能 通过事务处理机制 将多次DOM修改的结果一次性的更新到页面上 从而有效减少页面渲染的次数 减少修改DOM的重绘重排次数 提高渲染性能。

3. 使用原理：解析过程
   在代码渲染到页面之前 vue会将代码转换为一个对象『虚拟DOM』 以对象的形式来描述真实的DOM结构 最终渲染到DOM页面上
   当每次数据发生变化前 虚拟DOM都会缓存一份 变化之时 现在的虚拟DOM会和缓存的虚拟DOM进行比较 使用vue内部封装的diff算法来进行比较 渲染时修改改变的变化 原先没有发生的改变的通过原先的数据进行渲染
   
『题外话』
一个元素对象就包含TagName props Children等属性 虚拟DOM就是由很多元素对象组合的一个JS对象树
```

```html
<!-- 旧页面内容 -->
<ul id="list">
    <li class="item">哈哈</li>
    <li class="item">呵呵</li>
</ul>
<!-- 新页面内容 -->
<ul id="list">
    <li class="item">哈哈</li>
    <li class="item">今天是个好日子</li>
</ul>
```

```js
let oldVDOM = {             // 旧虚拟DOM
    tagName: 'ul',          // 标签名
    props: {                // 标签属性
        id: 'list'
    },
    children: [             // 标签子节点
        {
            tagName: 'li', props: { class: 'item' }, children: ['哈哈']
        },
        {
            tagName: 'li', props: { class: 'item' }, children: ['呵呵']
        }
    ]
}
```

```js
let oldVDOM = {            // 新虚拟DOM
    tagName: 'ul',         // 标签名
    props: {               // 标签属性
        id: 'list'
    },
    children: [            // 标签子节点
        {
            tagName: 'li', props: { class: 'item' }, children: ['哈哈']
        },
        {
            tagName: 'li', props: { class: 'item' }, children: ['今天是个好日子']
        }
    ]
}
```

> 此时 就出现两个新旧虚拟`DOM` 这个时候的新虚拟`DOM`是数据的最新状态
>
> 但是如果我们直接拿新虚拟`DOM`去渲染成真实DOM时 效率并不会比直接操作真实`DOM`高
>
> 错误：虚拟`DOM`比真实`DOM`快
>
> 正确：虚拟`DOM`算法操作真实`DOM `的性能高于直接操作真实`DOM`

## 10 `diff`算法的原理

[15张图，20分钟吃透Diff算法核心原理，我说的！！！ - 掘金 (juejin.cn)](https://juejin.cn/post/6994959998283907102)

**虚拟`DOM`+`diff`算法才能真正的提供性能**

> 如上的例子：如果使用`diff`算法 就会对比出 只有一个`li`标签发生了改变 才更新真实`DOM `只更新目标`li`标签  其他的节点都不变 就没有必要更新
>
> 所以 `diff`算法其实就是查出这个 `li`标签的算法

```sh
总结：
    Diff算法是一种对比算法 对比两者是新旧虚拟DOM 对比出是哪个虚拟节点更改了 找出这个虚拟节点 然后更新这个虚拟节点所对应的真实节点 而不用更新其他数据没发生过改变的节点 实现精准更新真实DOM 提高效率
```

```sh
原理：
1. 新旧对比的时候 只会在同层级进行比较 不会跨层级比较
2. diff算法是 深度优先算法  时间复杂度O(n)

对比流程：
1. 当数据更改时 会触发setter 并通过Dep.notify去通知所有订阅者
   订阅者就会调用patch方法 给真实DOM打补丁 更新相应视图
2. patch方法：对比同层的虚拟节点是否为同一类型的标签『sameVnode方法』
   不同：就直接将整个节点替换为新虚拟节点
   相同：进行执行『patchVnode』进行深层比对

注: 1. sameVnode方法: 是patch方法的关键性一步 
    2. patchVnode方法: 判断是否指向同一个对象 文本节点 子节点等 如果两者都有子节点 就执行 updateChildren进行比较子节点
    3. updateChildren方法: patchVnode中最重要的一个方法 新旧虚拟节点的子节点对比『首尾指针法』
       比较情况：
           oldS ==> newS『首首』
           oldS ==> newE『首尾』
           oldE ==> newS『尾首』 
           oldE ==> newE『尾尾』 
           使用新旧节点的不同key值去比较对比 
```

 ![](https://gitee.com/zhizhu_wlz/image-for-md/raw/master/1db54647698e4c76b6fc38a02067ad72~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

```sh
为什么v-for循环不建议index作为key
举例：在列表最前面插入一个li标签 整个列表都将index作为key

1. 在进行子节点的diff算法过程中 会进行旧首和新首节点的对比 key都为0 就会更新为新dom树的文本 
   最后新增一个节点居然是原本就有的节点 就因为key值之前没有出现过 所以最终就是所有li标签都更新了
  
2. 所以最好使用一个独一无二的值作为key 这么做的话原有节点的key值就是不变的 更新前后的key值一样 内容相同 就会复用
   如果新增节点 原来是没有它的key值的 那就会被当做新的节点 增加到真实DOM上
```

# 2023年4月19日 星期三

## 1. 微信小程序的生命周期函数有哪些

```sh
生命周期：实质上是一堆在特定时期执行的函数
1. 应用的生命周期
   小程序的生命周期是在app.js中调用的 通过App函数来注册一个小程序
   onLaunch 小程序初始化完成时触发 全局只触发一次
   onShow   小程序启动 或从后台进入前台显示时触发
   onHide   进入后台触发
   onError
   onPageNotFount
   onUnhandleRejected  有未处理的Promise拒绝时触发
   onThemeChange
   
2. 页面的生命周期
   当切换到一个新的页面时 就会调用的生命周期函数 通过App函数来注册一个页面
   onLoad: 监听页面加载 发送请求获取数据
   onShow: 监听页面显示 请求数据
   onReady: 页面初次渲染完成 获取页面元素『少用』
   onHide: 页面隐藏
   onUnload: 页面卸载
   
3. 组件的生命周期
   指的是组件自身的一些函数 这些函数在特殊的时间点或遇到一些特殊的框架事件被自动触发 通过Component进行注册组件
   created   页面加载
   attached  页面显示
   ready     页面初次渲染完成
   moved     页面隐藏完成
   datached  页面卸载
   error     组件方法出错
```

## 2. 小程序路由跳转

```sh
wx.navigateTo(Object): 保留当前页面 跳转到非TabBar页面 可以Back返回  『新页面入栈』
wx.redirectTo(Object): 重定向 关闭当前页面 跳转非TabBar 但返回页面需要重新加载 增加了显示时间 『当前出栈 新页面入栈』
wx.switchTab(Object): 跳转到TabBar页面 关闭所有非页面 不能带参数      『全部出栈 留下新的tab页面』
wx.navigateBack(Object)     『页面不断出栈 直到目标返回页 新页面入栈』
wx.reLaunch(Object): 关闭所有页面，打开到应用内的某个页面             『页面全部出栈 只留下新页面』
```



# 2023年4月23日 星期日

## 1. 进程和线程的区别

```sh
1. 资源：
   进程是CPU资源分配的最小单位 可以拥有资源和运行程序的最小单位
   线程是CPU调度的最小单位 是建立在进程基础上的一次程序运行单位 一个进程可以有多个线程
   
2. 独立应用：
   进程可以作为一个独立应用使用 线程不可以
   
3. 通信：
   进程间是相互隔离的 只能借助进程间通信
   线程是共享同一个进程的资源 所以可以直接进行通信
   
4. 调度
   进程切换比线程切换开销更大
   
5. 系统开销
   创建或撤销进程的时候 操作系统都要为其分配或回收资源 开销远远大于线程的创建与撤销
   线程切换的时候只需保存和设置少量寄存器内容 开销较小
```

```sh
浏览器的进程：
1. 浏览器进程：界面显示 用户交互 存储等
2. 网络进程：负责网络资源的加载
3. GPU进程：
4. 渲染进程：将html+css+js转换为用户可以与之交互的网页
            排版引擎和JavaScript引擎都运行在该进程中
            会为浏览器中每个tab标签创建一个渲染进程
5. 插件进程
```

```sh
渲染进程中的线程：
1. GUI渲染线程：解析html+css 构建dom树和cssom树 构建渲染树和绘制页面。当引起重绘和回流，线程就会执行。
   和JS引擎线程是互斥的 一方执行另一方挂起
2. JS引擎线程：负责处理JavaScript脚本程序 解析JavaScript脚本
   如果JS执行的时间过长 会造成页面的渲染不连贯 导致页面渲染加载阻塞
3. 事件触发线程 当对应的事件符合触发条件就会被添加到待处理队列的队尾 等待JS引擎的处理
4. 定时器触发线程：定时器的任务在设定的时间不一定能够准时执行 而是在指定时间点将任务添加到事件队列中 不能小于4ms
5. 异步http请求线程：将回调函数放入事件队列中 等待JS引擎空闲后执行
```

**注意**：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执⾏）；

## 2. 进程之前的通信方式

```sh
管道通信：
1. 最基本的进程间通信机制。
2. 操作系统在内核中开辟的一段缓冲区 进程1可以将需要交互的数据拷贝到这段缓存区 进程2就可以读取了
3. 特点：
   只能单向通信
   只能有血缘关系的进程进行通信
   依赖文件系统  管道内部提供了同步进制
   
消息队列通信：
1. 消息队列就是一个消息的列表。提供了一种从一个进程向另一个进程发送一个数据块的方法。
2. 使用消息队列可能会受到数据块最大长度的限制约束等
3. 消息的读取 是从一个进程拷贝到另一个进程

信号量通信
1. 共享内存最大的问题就是多线程竞争内存的问题 类似线程安全问题
2. 信号量本质是一个计数器 实现进程之间的互斥与同步
   当有进程访问内存1时 就将信号量的值设为0
   那么其他进程就知道内存1已经有进程在访问了 其他的进程就访问不了
   
信号通信
1. Unix系统中最古老的进程间通信的方法之一

共享内存通信
1. 映射一段能被其他进程所访问的内存 这段共享内存可以被多个进程调问
2. 是最快的IPC方式？

套接字通信
1. 上面的管道 消息队列 信号量 信号 共享内存都是多个进程在同一台主机之间的通信。
2. Socket通信方式：
```

## 3. 死锁产⽣的原因？ 如果解决死锁的问题？

```sh
1. 概念：死锁是指多个进程在运行过程中因为争夺资源而造成的一种僵局。当进程处于这种状态时 若无外力作用 它们都无法向前推进

2. 资源包括：
   可剥夺资源：CPU 主存等
   不可剥夺资源： 磁带机 打印机等
   
3. 原因： 
   1. 竞争不可剥夺资源：进程p1已占用了打印机 进程p2继续要求打印机打印将造成阻塞
   2. 竞争临时资源：包括硬件账单 信号 消息 缓存区中的消息等 消息通信顺序操作不当 就会产生死锁
   3. 进程间推进顺序 非法：若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发⽣死锁。
```

![image-20230423223104534](https://gitee.com/zhizhu_wlz/image-for-md/raw/master/image-20230423223104534.png)

```sh
预防死锁
1. 资源一次性分配
2. 如果该进程得不到其中一个资源的分配 那也不分配给它其他的资源
3. 当某个进程得到了部分资源 但得不到其他资源 则释放已占有的资源
4. 给每类资源赋予一个编号 每一个进程按照编号顺序来请求资源 释放则相反
```

## 4. 对浏览器的缓存机制的理解

## 5. 协商缓存和强缓存的区别

```sh
使⽤强缓存策略时，如果缓存资源有效，则直接使⽤缓存资源，不必再向服务器发起请求。
1. 主要就是判断是否过期；
   服务器在响应头添加Expires属性来制定资源的过期时间 在时间内可以被缓存 不必发送请求『HTTP1.0』
   Cache-Control属性提供了对资源的缓存更精确的控制 其中有一个max-age=是设置缓存的最大有效期 单位为妙 『HTTP1.1』
```

