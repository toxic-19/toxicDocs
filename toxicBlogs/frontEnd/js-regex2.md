---
title: 正则表达式(2)
date: 2022-2-5
tags:
 - 正则表达式
 - JavaScript
categories:
 - 前端
sidebar: 'auto'

---

 参考链接：:punch:[JS正则表达式完整教程（略长）](https://juejin.cn/post/6844903487155732494#heading-1)

## 1. 基础

**正则表达式是匹配模式，要么匹配字符，要么匹配位置。**

**正则表达式之所以强大，是因为其能实现模糊匹配。**精确匹配是没什么意义的。

### 1.1 字符匹配

:ear: 1. **横向模糊匹配**：指的是长度并不固定。**{m,n}连续最少出现m次，最多n次**  
         比如说：`/ab{2,6}c/`：`字符a 2~5个字符b 字符c`

```js
let regex = /ab{2,5}c/g;
let strings = "abc abbc abbbc abbbbc abbbbbc abbbbbbc";
console.log(strings.match(regex))  // [ 'abbc', 'abbbc', 'abbbbc', 'abbbbbc' ]
// g：全局匹配。即在目标字符串中按顺序找到满足匹配模式的所有子串。即global
```

:ear: 2. **纵向模糊匹配**：具体到某一位字符时，可以有多个选择，多种可能。**使用字符组 `[abc]`**：表示该字符可以是`a,b,c`中任何一个。

```js
regex = /a[123]bc/g;
strings = "a0bc a1bc a2bc a3bc a4bc"
console.log(strings.match(regex)) // [ 'a1bc', 'a2bc', 'a3bc' ]
```

:ear: 3. **字符组**：

+ 如果字符很多，可以使用**范围表示法**。<u>使用`-`来省略与简写。</u>

  当然如果` - `变为匹配内容。比如说匹配 `“a","-","z"` 。则为`[-az]  [az-]   [a\-z]`。要么开头，要么结尾，要么转义。

+ 排除字符法：可以是任何东西，不可以是`"a","b","c"` 。使用排除字符组【反义字符组】。例如 `[^abc]` `^` 表示求反

```tex
1. \d : [0-9] 表示一位数字
2. \D : [^0-9] 表示除了数字之外的任意字符
3. \w : [0-9a-zA-Z_] 表示数字，大小字母和下划线
4. \W : [^0-9a-zA-Z_] 非单词字符
5. \s : [ \t\v\n\r\f] 表示空白符，包括空格，制表符，换行符，回车符，换页符
6. \S : 非空白符
7.  . : [^\n\r\u2028\u2029] 通配符，表示几乎任意字符。换行符，回车符，行分隔符，段分隔符除外。
8. 匹配任何字符 [\d\D] [\w\W] [\s\S] [^]
```

:ear: 4. **量词**

```tsx
1. {m,} : x >= m
2. {m}  : x = m
3. ? = {0,1} : x = 0|1
4. + = {1,}  : x >= 1
5. * = {0,}  : x = 0|其他
```

+ 贪婪匹配：尽可能多的匹配。

+ 惰性匹配：和贪婪匹配相反。当满足最少要求时，就不再往下匹配。所以在下面例子中：每个子串有可能满足多次。

  **通过在量词后面加上?就可实现惰性匹配**  `{m,n}? {m,}? ?? +? *?`

```js
// 贪婪匹配
regex = /\d{2,5}/g;
strings = "1 12 123 1234 12345 123456";
console.log(strings.match(regex));
// [ '12', '123', '1234', '12345', '12345' ]

// 惰性匹配
regex = /\d{2,5}?/g;
console.log(strings.match(regex));
// [
//   '12', '12', '12',
//   '34', '12', '34',
//   '12', '34', '56'
// ]
```

:ear: **多选分支**： 用`|`【管道符】分隔 类似于` or `的意思。表示任选其中之一。分支结构也是惰性的，即当排在|更前面的匹配上了，后面的就不再尝试。

```js
regex = /good|goodbye/g;
let string = "goodbye";
console.log(string.match(regex)); // [ 'good' ]

regex = /goodbye|good/g;
console.log(string.match(regex)) // [ 'goodbye' ]
```

### 小结案例：

:sunflower: 1. **匹配16进制颜色值**

要求匹配：`#ffbbad  #Fc01DF  #FFF  #ffE`

```tsx
// 16进制有 0-9 a-f A-F 其中数字与字符都可以出现3或6次
// 任选一个 [0-9a-fA-F] 然后出现次数
let regex = /#[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/; // 前面加个#号。
```

:sunflower: 2. **匹配24小时制**

要求匹配：  `23.59 02.07`

```tsx
// 小数点前：00-23  小数点后：00-59
// 当第一位为0,1时，第二位可以为0-9；但是为2时只能为0-3
let regex1 = /[01][0-9]|[2][0-3]/
// 第三位为0-5 第四位为0-9
let regex2 = /[0-5][0-9]/
let regex = /([01][0-9]|[2][0-3]):[0-5][0-9]/
```



### 1.2 位置匹配

## 2. 括号

## 3. 匹配原理

## 4. 拆分正则表达式

## 5. 构建正则表达式

## 6. 注意

